<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Text cu 3 layere (simplu)</title>

  <!-- React 18 + OpenType -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/opentype.js@1.3.4/dist/opentype.min.js"></script>

  <style>
    :root { --ui: #e5e7eb; --grid: #eef2f7; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#fafafa; }
    .wrap { max-width: 1200px; margin: 24px auto; padding: 0 16px; }
    .row { display: grid; grid-template-columns: 360px 1fr; gap: 16px; align-items: start; }
    .card { background: #fff; border:1px solid #e5e7eb; border-radius: 12px; padding: 16px; }

    .label { font-size: 12px; color:#374151; margin-top: 8px; margin-bottom: 4px; }
    input[type="number"], input[type="text"], select {
      width: 100%; padding:8px 10px; border-radius:8px;
      border:1px solid #d1d5db; background:#fff; outline:none;
    }
    input[type="color"]{ width:44px; height:28px; padding:0; border:1px solid #d1d5db; border-radius:8px; background:#fff;}
    .controls-row { display: grid; grid-template-columns: 1fr 1fr; gap:8px; }

    .grid {
      width:100%; height:700px; border-radius:12px; border:1px solid var(--ui); background:#fff;
      background-image:
        linear-gradient(var(--grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid) 1px, transparent 1px);
      background-size: 20px 20px, 20px 20px;
      position: relative; overflow: hidden;
    }

    .btn {
      display:inline-block; padding:10px 14px; border-radius:10px; border:1px solid #111827;
      background:#111827; color:#fff; cursor:pointer; user-select:none; text-align:center;
    }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .hint { font-size:12px; color:#6b7280; margin-top:10px; }
    .svg-preview { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <div class="wrap">
    <h2>Text cu 3 layere (simplu)</h2>
    <div id="app" class="row"></div>
  </div>

  <script>
    const { useEffect, useMemo, useRef, useState } = React;
    const DESIGN_W = 1200, DESIGN_H = 700;

    // fonts.json -> [{id, label, file}]
    function loadFontsList() {
      console.log("Loading fonts.json...");
      return fetch("/assets/fonts/fonts.json", { cache: "no-store" })
        .then(r => {
          console.log("fonts.json response status:", r.status);
          if (!r.ok) throw new Error("fonts.json not found");
          return r.json();
        })
        .then(list => {
          console.log("Loaded fonts list:", list.length, "fonts");
          return Array.isArray(list) ? list.filter(f => f && (f.id || f.file) && f.file) : [];
        });
    }
    async function loadFontFile(url) {
      console.log("Loading font file:", url);
      const r = await fetch(url, { cache: "no-store" });
      console.log("Font fetch status:", r.status, "for", url);
      if (!r.ok) throw new Error("TTF fetch failed: " + url);
      const buf = await r.arrayBuffer();
      console.log("Font buffer size:", buf.byteLength, "for", url);
      try {
        const font = opentype.parse(buf);
        console.log("Font parsed successfully:", font.names.fontFamily?.en || "Unknown");
        return font;
      } catch (e) {
        console.error("OpenType parse error for", url, e);
        throw e;
      }
    }

    // generează path d din text (un rând)
    function makePathFromText(font, text, fontSize, x, y, letterSpacing=0, glyphsOverride=null) {
      if (!font || !text) return { d: "", bbox: null };
      const glyphs = glyphsOverride || font.stringToGlyphs(text);
      if (!glyphs.length) return { d: "", bbox: null };
      const scale = fontSize / font.unitsPerEm;
      let cx = x, d = "";
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      for (let i=0; i<glyphs.length; i++) {
        const g = glyphs[i], prev = i ? glyphs[i-1] : null;
        if (prev) cx += font.getKerningValue(prev, g) * scale;
        const p = g.getPath(cx, y, fontSize);
        d += p.toPathData(3) + " ";
        const box = p.getBoundingBox();
        if (Number.isFinite(box.x1) && Number.isFinite(box.x2) && Number.isFinite(box.y1) && Number.isFinite(box.y2)) {
          if (box.x1 < minX) minX = box.x1;
          if (box.y1 < minY) minY = box.y1;
          if (box.x2 > maxX) maxX = box.x2;
          if (box.y2 > maxY) maxY = box.y2;
        }
        cx += (g.advanceWidth || font.unitsPerEm) * scale;
        if (i < glyphs.length - 1) cx += letterSpacing;
      }
      const hasBox = Number.isFinite(minX) && Number.isFinite(minY) && Number.isFinite(maxX) && Number.isFinite(maxY);
      return { d: d.trim(), bbox: hasBox ? { minX, minY, maxX, maxY } : null };
    }

    function Preview({
      svgRef,
      pathD,
      textBBox,
      colors,
      pad,
      rounded,
      fontSize,
      setFontSize,
      lineData,
      lineOffsets
    }) {
      const dragRef   = useRef({ active: false, index: -1, sx: 0, sy: 0, ox: 0, oy: 0 });
      const scaleRef  = useRef({ active: false, cx: 0, cy: 0, startDist: 1, startSize: fontSize });
      const anchorRef = useRef({ active: false, cx: 0, cy: 0 });
      const wheelTimerRef = useRef(null);

      const clientToSVG = React.useCallback((evt) => {
        const svg = svgRef?.current || null;
        if (!svg) return { x: 0, y: 0 };
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX; pt.y = evt.clientY;
        const m = svg.getScreenCTM(); if (!m) return { x: 0, y: 0 };
        const inv = m.inverse(); const p = inv ? pt.matrixTransform(inv) : pt;
        return { x: p.x, y: p.y };
      }, [svgRef]);

      const onMove = React.useCallback((evt) => {
        if (!dragRef.current.active) return;
        evt.preventDefault();
        const { x, y } = clientToSVG(evt);
        const dx = Math.round(x - dragRef.current.sx);
        const dy = Math.round(y - dragRef.current.sy);
        const target = lineOffsets?.[dragRef.current.index];
        if (!target) return;
        if (target.setX) target.setX(dragRef.current.ox + dx);
        if (target.setY) target.setY(dragRef.current.oy + dy);
      }, [clientToSVG, lineOffsets]);

      const onUp = React.useCallback(() => {
        if (!dragRef.current.active) return;
        dragRef.current.active = false;
        dragRef.current.index = -1;
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
      }, [onMove]);

      const beginDrag = React.useCallback((evt, idx) => {
        const target = lineOffsets?.[idx];
        if (!target) return;
        evt.preventDefault();
        const { x, y } = clientToSVG(evt);
        dragRef.current = {
          active: true,
          index: idx,
          sx: x,
          sy: y,
          ox: target.x || 0,
          oy: target.y || 0
        };
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp, { once: true });
      }, [clientToSVG, lineOffsets, onMove, onUp]);

      const centerFromBBox = (bb) => bb ? {
        cx: (bb.minX + bb.maxX) / 2,
        cy: (bb.minY + bb.maxY) / 2
      } : null;

      const scaleCenter = useMemo(() => centerFromBBox(textBBox), [textBBox]);

      const onScaleMove = React.useCallback((evt) => {
        if (!scaleRef.current.active) return;
        evt.preventDefault();
        const { x, y } = clientToSVG(evt);
        const distance = Math.hypot(x - scaleRef.current.cx, y - scaleRef.current.cy) || 1;
        let ratio = distance / scaleRef.current.startDist;
        if (evt.shiftKey) ratio = 1 + (ratio - 1) * 0.35;
        let next = scaleRef.current.startSize * ratio;
        next = Math.max(20, Math.min(800, next));
        setFontSize(Math.round(next));
      }, [clientToSVG, setFontSize]);

      const onScaleUp = React.useCallback(() => {
        if (!scaleRef.current.active) return;
        scaleRef.current.active = false;
        window.removeEventListener('mousemove', onScaleMove);
        window.removeEventListener('mouseup', onScaleUp);
        anchorRef.current.active = false;
      }, [onScaleMove]);

      const onScaleDown = React.useCallback((evt) => {
        if (!textBBox || !scaleCenter) return;
        evt.preventDefault(); evt.stopPropagation();
        const { x, y } = clientToSVG(evt);
        const dist = Math.hypot(x - scaleCenter.cx, y - scaleCenter.cy) || 1;
        scaleRef.current = {
          active: true, cx: scaleCenter.cx, cy: scaleCenter.cy,
          startDist: dist, startSize: fontSize
        };
        anchorRef.current = { active: true, cx: scaleCenter.cx, cy: scaleCenter.cy };
        window.addEventListener('mousemove', onScaleMove);
        window.addEventListener('mouseup', onScaleUp, { once: true });
      }, [clientToSVG, fontSize, onScaleMove, onScaleUp, scaleCenter, textBBox]);

      useEffect(() => {
        const svg = svgRef.current;
        if (!svg) return;
        const onWheel = (e) => {
          if (!e.ctrlKey || !textBBox) return;
          e.preventDefault();
          const c = centerFromBBox(textBBox);
          if (!anchorRef.current.active && c) anchorRef.current = { active: true, cx: c.cx, cy: c.cy };
          const zoomIn = e.deltaY < 0;
          const base = zoomIn ? 1.12 : (1 / 1.12);
          const factor = e.shiftKey ? (1 + (base - 1) * 0.35) : base;
          let next = fontSize * factor;
          next = Math.max(20, Math.min(800, next));
          setFontSize(Math.round(next));
          if (wheelTimerRef.current) clearTimeout(wheelTimerRef.current);
          wheelTimerRef.current = setTimeout(() => { anchorRef.current.active = false; }, 200);
        };
        svg.addEventListener('wheel', onWheel, { passive: false });
        return () => {
          svg.removeEventListener('wheel', onWheel);
          if (wheelTimerRef.current) clearTimeout(wheelTimerRef.current);
        };
      }, [fontSize, textBBox, setFontSize]);

      useEffect(() => {
        if (!anchorRef.current.active || !textBBox || !lineOffsets?.length) return;
        const c = centerFromBBox(textBBox);
        if (!c) return;
        const dx = anchorRef.current.cx - c.cx;
        const dy = anchorRef.current.cy - c.cy;
        if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
          lineOffsets.forEach((item) => {
            if (item?.setX) item.setX((v) => v + dx);
            if (item?.setY) item.setY((v) => v + dy);
          });
        }
      }, [textBBox, lineOffsets]);

      useEffect(() => () => {
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        window.removeEventListener('mousemove', onScaleMove);
        window.removeEventListener('mouseup', onScaleUp);
      }, [onMove, onScaleMove, onScaleUp, onUp]);

      const lineJoin = rounded ? "round" : "miter";
      const midStroke  = Math.max(8,  Math.round(pad * 0.55));
      const baseStroke = Math.max(12, pad);
      const { base = "#111827", mid = "#ef4444", top = "#ffffff" } = colors || {};
      const showHandle = Boolean(pathD && textBBox);

      return React.createElement("svg", {
        ref: svgRef, xmlns: "http://www.w3.org/2000/svg",
        width: "100%", height: "100%",
        viewBox: `0 0 ${DESIGN_W} ${DESIGN_H}`,
        preserveAspectRatio: "xMidYMid meet",
        className: "svg-preview",
        onMouseLeave: onUp
      }, [
        React.createElement("line", { key: "cx", x1: DESIGN_W/2, y1: 0, x2: DESIGN_W/2, y2: DESIGN_H, stroke: "#cbd5e1", "stroke-width": 1 }),
        React.createElement("line", { key: "cy", x1: 0, y1: DESIGN_H/2, x2: DESIGN_W, y2: DESIGN_H/2, stroke: "#cbd5e1", "stroke-width": 1 }),

        pathD ? React.createElement("path", {
          key: "base", d: pathD, fill: "none", stroke: base,
          "stroke-width": baseStroke, "stroke-linejoin": lineJoin, "stroke-linecap": rounded ? "round" : "butt"
        }) : null,

        pathD ? React.createElement("path", {
          key: "mid", d: pathD, fill: "none", stroke: mid,
          "stroke-width": midStroke, "stroke-linejoin": lineJoin, "stroke-linecap": rounded ? "round" : "butt"
        }) : null,

        pathD ? React.createElement("path", { key: "top", d: pathD, fill: top }) : null,

        ...(lineData || []).map((line) => React.createElement("path", {
          key: `drag-${line.index}`,
          d: line.d,
          fill: "transparent",
          stroke: "transparent",
          "stroke-width": 20,
          style: { cursor: "move" },
          onMouseDown: (evt) => beginDrag(evt, line.index)
        })),

        showHandle ? React.createElement("circle", {
          key: "scale", cx: textBBox.maxX, cy: textBBox.maxY, r: 14,
          fill: base, stroke: "#ffffff", "stroke-width": 2,
          style: { cursor: "nwse-resize" }, onMouseDown: onScaleDown
        }) : null
      ]);
    }

    function App(){
      // fonts
      const [fonts, setFonts] = useState([]);
      const [fontId, setFontId] = useState("");
      const [font, setFont] = useState(null);
      const [loadMsg, setLoadMsg] = useState("");

      // text (până la 3 rânduri)
      const [text, setText]   = useState("Blake");
      const [text2, setText2] = useState("");
      const [text3, setText3] = useState("");
      const [lineSpacing, setLineSpacing] = useState(0.95);
      const [letterSpacing, setLetterSpacing] = useState(0);

      // layout
      const [fontSize, setFontSize] = useState(140);
      const [off1X, setOff1X] = useState(0);
      const [off1Y, setOff1Y] = useState(0);
      const [off2X, setOff2X] = useState(0);
      const [off2Y, setOff2Y] = useState(0);
      const [off3X, setOff3X] = useState(0);
      const [off3Y, setOff3Y] = useState(0);

      // colors & look
      const [cTop, setCTop]   = useState("#ffffff");
      const [cMid, setCMid]   = useState("#ef4444");
      const [cBase, setCBase] = useState("#111827");
      const [pad, setPad]     = useState(28);
      const [round, setRound] = useState(true);

      // load fonts list
      useEffect(() => {
        (async () => {
          try {
            const list = await loadFontsList();
            setFonts(list);
            if (list.length) setFontId(list[0].id ?? list[0].file);
          } catch (e) {
            setLoadMsg("Nu pot încărca fonts.json ("+e.message+")");
          }
        })();
      }, []);

      // load selected font
      useEffect(() => {
        let stop = false;
        (async () => {
          const it = fonts.find(f => (f.id ?? f.file) === fontId);
          if (!it) { setFont(null); return; }
          try {
            setLoadMsg("Se încarcă fontul...");
            const f = await loadFontFile(it.file);
            if (!stop) { setFont(f); setLoadMsg(""); }
          } catch (e) {
            if (!stop) { setFont(null); setLoadMsg("Eroare font: " + e.message); }
          }
        })();
        return () => { stop = true; };
      }, [fontId, fonts]);

      // generează path-urile pentru până la 3 rânduri, centrate pe orizontală
      const layout = useMemo(() => {
        if (!font) return { d: "", bbox: null, lines: [] };
        const rawLines = [text, text2, text3].filter(Boolean);
        if (!rawLines.length) return { d: "", bbox: null, lines: [] };

        const spacing = Number.isFinite(lineSpacing) && lineSpacing > 0 ? lineSpacing : 1;
        const totalHeight = fontSize + (rawLines.length - 1) * fontSize * spacing;
        const baselineTop = DESIGN_H / 2 - totalHeight / 2;

        let combinedPath = "";
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const perLine = [];
        const offsets = [
          { x: off1X, y: off1Y },
          { x: off2X, y: off2Y },
          { x: off3X, y: off3Y }
        ];

        for (let idx = 0; idx < rawLines.length; idx++) {
          const value = rawLines[idx];
          const glyphs = font.stringToGlyphs(value);
          if (!glyphs.length) continue;

          const scale = fontSize / font.unitsPerEm;
          let width = 0, prev = null;
          for (let i = 0; i < glyphs.length; i++) {
            const g = glyphs[i];
            if (prev) width += font.getKerningValue(prev, g) * scale;
            width += (g.advanceWidth || font.unitsPerEm) * scale;
            if (i < glyphs.length - 1) width += letterSpacing;
            prev = g;
          }

          const baseLine = baselineTop + fontSize + idx * fontSize * spacing;
          const off = offsets[idx] || { x: 0, y: 0 };
          const y = Math.round(baseLine) + off.y;
          const x = DESIGN_W / 2 - width / 2 + off.x;

          const { d, bbox } = makePathFromText(font, value, fontSize, x, y, letterSpacing, glyphs);
          if (!d) continue;

          combinedPath += combinedPath ? ` ${d}` : d;
          perLine.push({ d, bbox, index: idx });

          if (bbox) {
            if (bbox.minX < minX) minX = bbox.minX;
            if (bbox.minY < minY) minY = bbox.minY;
            if (bbox.maxX > maxX) maxX = bbox.maxX;
            if (bbox.maxY > maxY) maxY = bbox.maxY;
          }
        }

        const hasBox = Number.isFinite(minX) && Number.isFinite(minY) && Number.isFinite(maxX) && Number.isFinite(maxY);
        return { d: combinedPath, bbox: hasBox ? { minX, minY, maxX, maxY } : null, lines: perLine };
      }, [font, text, text2, text3, fontSize, off1X, off1Y, off2X, off2Y, off3X, off3Y, lineSpacing, letterSpacing]);

      const { d: pathD, bbox: textBBox, lines: lineData } = layout;

      const svgRef = useRef(null);
      const previewColors = useMemo(() => ({ top: cTop, mid: cMid, base: cBase }), [cTop, cMid, cBase]);

      const lineOffsets = useMemo(() => ([
        { x: off1X, y: off1Y, setX: setOff1X, setY: setOff1Y },
        { x: off2X, y: off2Y, setX: setOff2X, setY: setOff2Y },
        { x: off3X, y: off3Y, setX: setOff3X, setY: setOff3Y }
      ]), [off1X, off1Y, off2X, off2Y, off3X, off3Y]);

      function downloadSVG(){
        const svg = svgRef.current;
        if (!svg) return;
        const xml = new XMLSerializer().serializeToString(svg);
        const blob = new Blob([xml], { type: "image/svg+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "text-3layers.svg";
        a.click();
        URL.revokeObjectURL(a.href);
      }

      function downloadSingleLayer(layerKey){
        if (!pathD) return;
        const lineJoin = round ? "round" : "miter";
        const lineCap = round ? "round" : "butt";
        const midStroke = Math.max(8, Math.round(pad * 0.55));
        const baseStroke = Math.max(12, pad);

        let layerSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${DESIGN_W} ${DESIGN_H}" width="${DESIGN_W}" height="${DESIGN_H}">`;
        if (layerKey === "top") {
          layerSVG += `<path d="${pathD}" fill="${cTop}"/>`;
        } else if (layerKey === "mid") {
          layerSVG += `<path d="${pathD}" fill="none" stroke="${cMid}" stroke-width="${midStroke}" stroke-linejoin="${lineJoin}" stroke-linecap="${lineCap}"/>`;
        } else if (layerKey === "base") {
          layerSVG += `<path d="${pathD}" fill="none" stroke="${cBase}" stroke-width="${baseStroke}" stroke-linejoin="${lineJoin}" stroke-linecap="${lineCap}"/>`;
        } else {
          return;
        }
        layerSVG += `</svg>`;

        const blob = new Blob([layerSVG], { type: "image/svg+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `text-3layers-${layerKey}.svg`;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      return React.createElement(React.Fragment, null,
        React.createElement("div", { className:"card" }, [
          React.createElement("div", { className:"label" }, "Font"),
          React.createElement("select", { value: fontId, onChange: e=>setFontId(e.target.value) },
            fonts.map(f => React.createElement("option", { key:(f.id ?? f.file), value:(f.id ?? f.file) }, f.label || f.id || f.file))
          ),
          loadMsg ? React.createElement("div", { className:"hint" }, loadMsg) : null,

          React.createElement("div", { className:"label" }, "Text (rând 1)"),
          React.createElement("input", { type:"text", value:text, onInput:e=>setText(e.target.value) }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Text 2 (opțional)"),
          React.createElement("input", { type:"text", value:text2, onInput:e=>setText2(e.target.value) }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Text 3 (opțional)"),
          React.createElement("input", { type:"text", value:text3, onInput:e=>setText3(e.target.value) }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Spațiere rânduri"),
          React.createElement("input", {
            type:"number", step:"0.05", min:"0.4", max:"3",
            value: lineSpacing,
            onInput: e => {
              const v = parseFloat(e.target.value);
              setLineSpacing(Number.isFinite(v) && v > 0 ? Math.min(3, Math.max(0.4, v)) : 0.95);
            }
          }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Font size"),
          React.createElement("input", { type:"number", value:fontSize, min:10, max:800, onInput:e=>setFontSize(+e.target.value||0) }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Spațiere litere"),
          React.createElement("input", {
            type:"number",
            step:"0.5",
            min:"-10",
            max:"100",
            value: letterSpacing,
            onInput: e => {
              const v = parseFloat(e.target.value);
              setLetterSpacing(Number.isFinite(v) ? Math.max(-10, Math.min(100, v)) : 0);
            }
          }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Offset Rând 1"),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "X"),
              React.createElement("input", { type:"number", value:off1X, onInput:e=>setOff1X(+e.target.value||0) })
            ]),
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Y"),
              React.createElement("input", { type:"number", value:off1Y, onInput:e=>setOff1Y(+e.target.value||0) })
            ])
          ]),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Offset Rând 2"),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "X"),
              React.createElement("input", { type:"number", value:off2X, onInput:e=>setOff2X(+e.target.value||0), disabled: !text2 })
            ]),
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Y"),
              React.createElement("input", { type:"number", value:off2Y, onInput:e=>setOff2Y(+e.target.value||0), disabled: !text2 })
            ])
          ]),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Offset Rând 3"),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "X"),
              React.createElement("input", { type:"number", value:off3X, onInput:e=>setOff3X(+e.target.value||0), disabled: !text3 })
            ]),
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Y"),
              React.createElement("input", { type:"number", value:off3Y, onInput:e=>setOff3Y(+e.target.value||0), disabled: !text3 })
            ])
          ]),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Culori layere"),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Layer 1 (Top)"),
              React.createElement("input", { type:"color", value:cTop, onInput:e=>setCTop(e.target.value) })
            ]),
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Layer 2 (Mijloc)"),
              React.createElement("input", { type:"color", value:cMid, onInput:e=>setCMid(e.target.value) })
            ])
          ]),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Layer 3 (Bază)"),
              React.createElement("input", { type:"color", value:cBase, onInput:e=>setCBase(e.target.value) })
            ]),
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Bubble padding"),
              React.createElement("input", { type:"range", min:8, max:80, value:pad, onInput:e=>setPad(+e.target.value) })
            ])
          ]),

          React.createElement("label", { style:{display:"flex", gap:8, alignItems:"center", marginTop:8} }, [
            React.createElement("input", { type:"checkbox", checked:round, onChange:e=>setRound(e.target.checked) }),
            React.createElement("span", null, "Rotunjit")
          ]),

          React.createElement("div", { style:{marginTop:12, display:"grid", gap:"8px"} }, [
            React.createElement("button", { className:"btn", onClick:downloadSVG, disabled: !pathD }, "Descarcă SVG (toate layerele)"),
            React.createElement("div", { className:"controls-row" }, [
              React.createElement("button", { className:"btn", onClick:()=>downloadSingleLayer("top"), disabled: !pathD }, "Descarcă Layer Top"),
              React.createElement("button", { className:"btn", onClick:()=>downloadSingleLayer("mid"), disabled: !pathD }, "Descarcă Layer Mid")
            ]),
            React.createElement("div", { className:"controls-row" }, [
              React.createElement("button", { className:"btn", onClick:()=>downloadSingleLayer("base"), disabled: !pathD }, "Descarcă Layer Bază")
            ])
          ]),

          React.createElement("div", { className:"hint" },
            "Fonturile sunt citite din /assets/fonts/fonts.json (chei: id, label, file).")
        ]),

        React.createElement("div", { className:"card" }, [
          React.createElement("div", { className:"grid" },
            React.createElement(Preview, {
              svgRef,
              pathD,
              textBBox,
              colors: previewColors,
              pad,
              rounded: round,
              fontSize,
              setFontSize,
              lineData,
              lineOffsets
            })
          )
        ])
      );
    }

    ReactDOM.createRoot(document.getElementById("app")).render(React.createElement(App));
    console.log("%cindex.html simplu – gata", "color:#16a34a");
  </script>
</body>
</html>