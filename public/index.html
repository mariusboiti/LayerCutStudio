<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>LayerCut Studio — LaserFilesPro</title>
  <!-- LCS boot stubs: prevenim "is not defined" pana se incarca istoricul -->
  <script>
  (function () {
    if (!('pushHistory' in window)) window.pushHistory = function(){};
    if (!('pushHistoryCoalesced' in window)) window.pushHistoryCoalesced = function(){};
    if (!('undo' in window)) window.undo = function(){};
    if (!('redo' in window)) window.redo = function(){};
    if (!('resetDesign' in window)) window.resetDesign = function(){};
    if (!window.LCS) {
      window.LCS = { __isStub__: true, __q__: [],
        setAdapters: function(){}, push: function(){}, undo: function(){}, redo: function(){},
        canUndo: function(){return false;}, canRedo: function(){return false;}, state: function(){return {};}
      };
    }
  })();
  </script>
  <!-- Boot stubs: previne "is not defined" pentru pushHistory/undo/redo -->
  <script>
  (function () {
    // Stubs o singură dată
    if (!('pushHistory' in window)) window.pushHistory = function(){};
    if (!('pushHistoryCoalesced' in window)) window.pushHistoryCoalesced = function(){};
    if (!('undo' in window)) window.undo = function(){};
    if (!('redo' in window)) window.redo = function(){};

    // Stub LCS minimal (opțional) ca să nu crape codul care îl atinge devreme
    if (!window.LCS) {
      window.LCS = { __isStub__: true, __q__: [],
        setAdapters: function(){}, push: function(){}, undo: function(){}, redo: function(){},
        canUndo: function(){return false;}, canRedo: function(){return false;}, state: function(){return {};}
      };
    }
  })();
  </script>
  <!-- LCS Boot Shim: previne erorile "LCS is undefined" si coada apelurile timpurii -->
  <script>
  (function () {
    if (window.LCS && !window.LCS.__isStub__) return;
    const q = [];
    const stub = {
      __isStub__: true,
      __q__: q,
      setAdapters: (...a) => q.push(['setAdapters', a]),
      push:        (...a) => q.push(['push', a]),
      undo:        (...a) => q.push(['undo', a]),
      redo:        (...a) => q.push(['redo', a]),
      canUndo:     () => false,
      canRedo:     () => false,
      state:       () => ({}),
      defaults:    {}
    };
    window.LCS = stub;
    // expune fallback-uri globale ca sa nu mai pice onClick={undo}
    if (!('undo' in window))  window.undo  = function () {};
    if (!('redo' in window))  window.redo  = function () {};
  })();
  </script>

  <!-- React 18 + OpenType -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/opentype.js@1.3.4/dist/opentype.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/clipper-lib@6.4.2/clipper.js"></script>

  <style>
    :root { --ui: #e5e7eb; --grid: #eef2f7; }
    /* feedback minim pt randul selectat (optional) */
    [data-selected="1"] { outline: 1px dashed #888; outline-offset: 2px; }
    /* Eye toggle */
    .layer-row{ display:flex; align-items:center; gap:8px; }
    .eye-btn{
      width:32px; height:28px; border-radius:8px;
      border:1px solid #d1d5db; background:#fff; cursor:pointer;
      display:flex; align-items:center; justify-content:center;
    }
    .eye-btn svg{ width:18px; height:18px; display:block; }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#fafafa; }
    /* Full-width: fără margini laterale, container întins pe toată pagina */
    .wrap { max-width: none; margin: 0; padding: 0; width: 100%; }
    /* A doua coloană umple tot, fără spațiu pe margini; păstrăm doar spațiul dintre coloane */
    .row { display: grid; grid-template-columns: 360px minmax(0,1fr); gap: 0 16px; align-items: start; }
    .card { background: #fff; border:1px solid #e5e7eb; border-radius: 12px; padding: 16px; }

    /* Titluri/etichete mai vizibile */
    h2 { font-size: 28px; font-weight: 800; margin: 16px 0; letter-spacing: .2px; }
    .label {
      font-size: 13px;
      font-weight: 600;
      color:#111827;
      margin-top: 8px;
      margin-bottom: 6px;
    }
    input[type="number"], input[type="text"], select {
      width: 100%; padding:8px 10px; border-radius:8px;
      border:1px solid #d1d5db; background:#fff; outline:none;
    }
    input[type="color"]{ width:44px; height:28px; padding:0; border:1px solid #d1d5db; border-radius:8px; background:#fff;}
    .controls-row { display: grid; grid-template-columns: 1fr 1fr; gap:8px; }
    /* Transform panel */
    .transform-grid { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .transform-grid .cell { display:flex; flex-direction:column; }
    .transform-grid .label { font-size:11px; font-weight:600; margin:0 0 2px 0; }
    .transform-grid input[type="number"]{ padding:6px 8px; font-size:13px; }
    /* triplet compact pe un singur rând */
    .controls-row-3 { display:grid; grid-template-columns: repeat(3, 1fr); gap:8px; }
    /* menține mic etichetele din grupul compact (spațiere rânduri / font size / litere) */
    .control-compact .label { font-size:11px; font-weight:600; margin: 0 0 2px 0; }
    .control-compact input[type="number"]{ padding:6px 8px; font-size:13px; }

    .grid {
      width:100%; height:700px; border-radius:12px; border:1px solid var(--ui); background:#fff;
      background-image:
        linear-gradient(var(--grid) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid) 1px, transparent 1px);
      background-size: 20px 20px, 20px 20px;
      position: relative; overflow: hidden;
    }

    .btn {
      display:inline-block; padding:10px 14px; border-radius:10px; border:1px solid #111827;
      background:#111827; color:#fff; cursor:pointer; user-select:none; text-align:center;
    }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .hint { font-size:12px; color:#6b7280; margin-top:10px; }

    /* icon button pentru toggle vizibilitate */
    .icon-btn{
      width:32px; height:32px; display:inline-grid; place-items:center;
      border:1px solid #d1d5db; border-radius:8px; background:#fff; cursor:pointer;
    }
    .icon-btn[aria-pressed="false"]{ opacity:.45; }
    .icon-btn svg{ display:block }

    /* HUD (ascuns) */
    .hud { display:none !important; }
   /* === Topbar (brand) === */
   .topbar{
     position: sticky; top: 0; z-index: 50;
     width:100%; background:#fff; border-bottom:1px solid #e5e7eb;
     box-shadow: 0 1px 0 rgba(0,0,0,0.02);
   }
   .topbar-inner{
     display:flex; align-items:center; gap:12px;
     padding:10px 16px;
   }
   .brand-logo{ width:28px; height:28px; display:inline-block; }
   .brand-name{ font-size:18px; font-weight:800; letter-spacing:.2px; color:#111827; }
   .brand-meta{ font-size:12px; color:#6b7280; }
   .brand-meta strong{ color:#111827; font-weight:700; }
   /* Zoom overlay jos-dreapta în canvas */
   .zoom-overlay{
     position:absolute; right:12px; bottom:12px;
     background:rgba(17,24,39,.9); color:#fff;
     padding:8px 12px; border-radius:10px;
     display:flex; gap:8px; align-items:center;
     box-shadow:0 6px 16px rgba(0,0,0,.2);
     backdrop-filter: blur(2px);
   }
   .zoom-overlay input[type="range"]{ width:170px; }
   .zoom-overlay .btn{ padding:6px 10px; background:#0f172a; border-color:#0f172a; }
   .svg-preview { display:block; width:100%; height:100%; }
  </style>
</head>
 <!-- KILO BEACON: confirm că acest index.html e servit -->
 <script>
   (function(){
     try {
       console.log("KILO ACTIVE FILE:", "D:/marius/Aplicatie Laser CUt/Aplicatie Laser CUt/public/index.html", "@", new Date().toISOString());
     } catch(e){}
   })();
 </script>
<body>
  <!-- ✅ Codex Patch OK — banner injectat imediat după <body> -->
  <div id="codex-dev-banner" style="position:fixed;z-index:99999;top:10px;right:10px;background:#0d6efd;color:#fff;padding:8px 12px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,.2);font:600 14px/1.2 system-ui;">
    ✅ Codex patch applied • public/index.html
  </div>
  <script>
    // auto-ascunde bannerul după 10s (poți șterge scriptul dacă vrei să rămână)
    (function(){
      var t = setTimeout(function(){
        var b = document.getElementById('codex-dev-banner');
        if (!b) return;
        b.style.transition = 'opacity .6s ease';
        b.style.opacity = '0';
        setTimeout(function(){ b.remove(); }, 650);
      }, 10000);
    })();
  </script>
    <!-- KILO TEST BANNER (ABS PATH) -->
    <div id="kilo-banner" style="position:sticky;top:0;z-index:9999;background:#2563eb;color:#fff;padding:8px 12px;text-align:center;font-weight:700;font-family:system-ui">
      KILO PATCH OK ✅ (ABS PATH)
    </div>
  <div class="topbar">
   <div class="topbar-inner">
     <!-- logo simplu (două forme suprapuse) -->
     <svg class="brand-logo" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
       <rect x="3" y="5" width="14" height="14" rx="3" fill="#111827"></rect>
       <rect x="7" y="3" width="14" height="14" rx="3" fill="#ef4444"></rect>
     </svg>
     <span class="brand-name">LayerCut Studio</span>
     <span class="brand-meta">by <strong>LaserFilesPro</strong> • <span id="appver">v0.1.0</span></span>
   </div>
 </div>

 <div class="wrap">
   <div id="lcs-project-tools" style="margin:16px auto;max-width:1200px;padding:16px;border:1px solid #d1d5db;border-radius:12px;background:#fff;box-shadow:0 1px 2px rgba(15,23,42,0.04);">
     <div style="display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between;">
       <div style="display:flex;flex-direction:column;gap:4px;">
         <div style="font-size:14px;font-weight:600;color:#111827;">Project &amp; autosave</div>
         <div id="lcs-status" style="font-size:12px;color:#6b7280;">Last saved: never</div>
       </div>
       <label style="display:flex;align-items:center;gap:6px;font-size:12px;color:#374151;">
         <input id="lcs-autosave" type="checkbox" style="width:16px;height:16px;" checked />
         Autosave to browser storage (60s)
       </label>
     </div>
     <div style="display:flex;flex-wrap:wrap;gap:8px;margin-top:12px;">
       <button id="lcs-save" style="padding:8px 10px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer;">💾 Save now (Ctrl+S)</button>
       <button id="lcs-load" style="padding:8px 10px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer;">⤓ Load from autosave</button>
       <button id="lcs-export" style="padding:8px 10px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer;">⬇ Export .lcs</button>
       <button id="lcs-export-svg" style="padding:8px 10px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer;">🧾 Export SVG for Laser</button>
       <button id="lcs-import-btn" style="padding:8px 10px;border:1px solid #d1d5db;border-radius:8px;background:#fff;cursor:pointer;">⬆ Import .lcs (Ctrl+O)</button>
       <input id="lcs-import" type="file" accept=".lcs,application/json" style="display:none" />
     </div>
   </div>
    <div id="app" class="row"></div>
  </div>
  <!-- HUD eliminat (ascuns) -->
  <div id="hud" class="hud"></div>

  <script>
   /* branding */
   const APP_NAME = "LayerCut Studio";
   const APP_VENDOR = "LaserFilesPro";
   const APP_VERSION = "v0.1.0";
   try {
     document.title = `${APP_NAME} — ${APP_VENDOR}`;
     var vEl = document.getElementById('appver'); if (vEl) vEl.textContent = APP_VERSION;
   } catch(_) {}

   /* ===== Guard numeric helpers: fixed() =====
      Unele patchuri au mutat/scris peste helper-ele vechi.
      Acest bloc garantează existența lui `fixed` înainte de folosire. */
   if (typeof window.fixed !== 'function') {
     window.fixed = function(value, digits){
       var d = (typeof digits === 'number' && digits >= 0) ? digits : 2;
       var n;
       if (typeof value === 'number') n = Number.isFinite(value) ? value : NaN;
       else if (value == null || value === '') n = NaN;
       else n = parseFloat(String(value).replace(',', '.'));
       if (!Number.isFinite(n)) {
         var base = '0'; if (d > 0) base += '.' + '0'.repeat(d);
         return base;
       }
       var p = Math.pow(10, d);
       var s = String(Math.round(n * p) / p);
       if (d > 0) {
         var i = s.indexOf('.');
         if (i === -1) s += '.' + '0'.repeat(d);
         else {
           var dec = s.length - i - 1;
           if (dec < d) s += '0'.repeat(d - dec);
         }
       }
       return s;
     };
   }
   // Creează și bindingul global `fixed` dacă lipsește (unele browsere nu-l leagă automat de window.*)
   if (typeof fixed === 'undefined') { var fixed = window.fixed; }

    const { useEffect, useMemo, useRef, useState, useCallback } = React;

    // HUD + error logs (utile la debug)
    window.addEventListener('error', ev => {
      console.log('[RUNTIME ERROR]', ev.message, 'at', ev.filename + ':' + ev.lineno + ':' + ev.colno);
    });
    // helper HUD global (no-op)
    window.__setHUD = () => {};

    // Helpers numerice (evită value invalid/NaN pe <input>)
    const toNum = (v, fb = 0) => {
      if (typeof v === 'number') return Number.isFinite(v) ? v : fb;
      if (v == null || v === '') return fb;
      const n = parseFloat(String(v).replace(',', '.'));
      return Number.isFinite(n) ? n : fb;
    };
    const toValueStr = (v) => {
      const n = toNum(v, null);
      return n === null ? '' : String(n);
    };

    const DESIGN_W = 1200, DESIGN_H = 700;
    const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
    
    // === Catalog SVG simplu (coordonate centrate, unități ~px) ===
    // d-urile sunt normalizate pentru mărime ~100px. Le vom scala/roti/translate în Preview.
    const SVG_CATALOG = [
      {
        id: "heart",
        label: "Inimă",
        d: "M 0 -28 C -16 -46 -48 -42 -48 -14 C -48 4 -32 20 0 40 C 32 20 48 4 48 -14 C 48 -42 16 -46 0 -28 Z"
      },
      {
        id: "star5",
        label: "Stea",
        d: "M 0 -50 L 14 -15 47 -15 23 7 29 40 0 22 -29 40 -23 7 -47 -15 -14 -15 Z"
      },
      {
        id: "bolt",
        label: "Fulger",
        d: "M -10 -50 L 18 -4 H 2 L 10 28 L -18 -10 H -2 Z"
      }
    ];
    // util: aplica transformări pe un path d (translate/scale/rotate) – foarte simplu: folosim un <g transform=...>
    function stickerTransform({x=DESIGN_W/2, y=DESIGN_H/2, scale=1, rotate=0}) {
      return `translate(${x} ${y}) rotate(${rotate}) scale(${scale})`;
    }

    // Fonts I/O
    function loadFontsList() {
      return fetch("/assets/fonts/fonts.json", { cache: "no-store" })
        .then(r => { if (!r.ok) throw new Error("fonts.json not found"); return r.json(); })
        .then(list => Array.isArray(list) ? list.filter(f => f && (f.id || f.file) && f.file) : []);
    }
    async function loadFontFile(url) {
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error("TTF fetch failed: " + url);
      const buf = await r.arrayBuffer();
      return opentype.parse(buf);
    }
    
    async function loadStickers(){
      try{
        const r = await fetch("/assets/stickers.json",{cache:"no-store"});
        if(!r.ok) throw new Error("stickers.json missing");
        const list = await r.json();
        return Array.isArray(list) ? list.filter(s => s && s.id && s.d) : [];
      }catch(_){ return []; }
    }

    function renderStickerLayers(st, def, idx){
      // st = instanța stickerului (x,y,scale,rotation, layerCount, layers)
      // def = definiția stickerului (def.d = path SVG)
      // idx = indexul pentru key
      const L = (st.layers || {});
      const rounded = (L.rounded !== false);
      const lj = rounded ? "round" : "miter";
      const lc = rounded ? "round" : "butt";

      function drawStroke(col, w){
        var wv = Number.isFinite(w) ? Math.max(0, Math.round(w)) : 0;
        if (wv <= 0) return null;
        return React.createElement("path", {
          key: "s-"+col+"-"+wv+"-"+Math.random(),
          d: def.d, fill: "none", stroke: col,
          strokeWidth: wv, strokeLinejoin: lj, strokeLinecap: lc
        });
      }
      function fillPath(col){
        return React.createElement("path", {
          key: "f-"+col+"-"+Math.random(),
          d: def.d, fill: col
        });
      }

      var pieces = [];

      // BASE
      if ((st.layerCount >= 2) && !(L.base && L.base.show === false)) {
        var baseCol = (L.base && L.base.color) || "#111827";
        pieces.push(fillPath(baseCol));
        var basePad = (L.base && L.base.pad) || 0;
        var s1 = drawStroke(baseCol, basePad);
        if (s1) pieces.push(s1);
      }

      // EXTRAS 4/5
      if (st.layerCount > 3 && Array.isArray(L.extras)) {
        var extraMax = Math.min(2, st.layerCount - 3);
        for (var i = 0; i < extraMax; i++){
          var ex = L.extras[i];
          if (ex && !(ex.show === false)) {
            var exCol = ex.color || (L.base && L.base.color) || "#111827";
            pieces.push(fillPath(exCol));
            var s2 = drawStroke(exCol, ex.pad || 0);
            if (s2) pieces.push(s2);
          }
        }
      }

      // MID
      if ((st.layerCount >= 3) && !(L.mid && L.mid.show === false)) {
        var midCol = (L.mid && L.mid.color) || "#ef4444";
        pieces.push(fillPath(midCol));
        var s3 = drawStroke(midCol, (L.mid && L.mid.pad) || 0);
        if (s3) pieces.push(s3);
      }

      // TOP (la final)
      if (!(L.top && L.top.show === false)) {
        var topCol = (L.top && L.top.color) || st.color || "#111827";
        var s4 = drawStroke(topCol, (L.top && L.top.pad) || 0);
        if (s4) pieces.push(s4);
        pieces.push(fillPath(topCol));
      }

      return pieces;
    }

    // Paths din text (un rând)
    function makePathFromText(font, text, fontSize, x, y, letterSpacing=0, glyphsOverride=null) {
      if (!font || !text) return { d: "", bbox: null };
      const glyphs = glyphsOverride || font.stringToGlyphs(text);
      if (!glyphs.length) return { d: "", bbox: null };
      const scale = fontSize / font.unitsPerEm;
      let cx = x, d = "";
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

      for (let i=0; i<glyphs.length; i++) {
        const g = glyphs[i], prev = i ? glyphs[i-1] : null;
        if (prev) cx += font.getKerningValue(prev, g) * scale;
        const p = g.getPath(cx, y, fontSize);
        d += p.toPathData(3) + " ";
        const box = p.getBoundingBox();
        if (Number.isFinite(box.x1) && Number.isFinite(box.x2) && Number.isFinite(box.y1) && Number.isFinite(box.y2)) {
          if (box.x1 < minX) minX = box.x1;
          if (box.y1 < minY) minY = box.y1;
          if (box.x2 > maxX) maxX = box.x2;
          if (box.y2 > maxY) maxY = box.y2;
        }
        cx += (g.advanceWidth || font.unitsPerEm) * scale;
        if (i < glyphs.length - 1) cx += letterSpacing;
      }
      const hasBox = Number.isFinite(minX) && Number.isFinite(minY) && Number.isFinite(maxX) && Number.isFinite(maxY);
      return { d: d.trim(), bbox: hasBox ? { minX, minY, maxX, maxY } : null };
    }

    // === Expand helpers (stroke -> filled shape) ===
    function otPathToPolys(otPath, flatnessPx=0.6){
      const polys=[]; let curr=[]; const add=(pt)=>{const l=curr[curr.length-1]; if(!l||l.X!==pt.x||l.Y!==pt.y) curr.push({X:pt.x,Y:pt.y});};
      let pen={x:0,y:0}, start={x:0,y:0};
      const chord=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
      const approxQ=(p0,p1,p2)=>chord(p0,p1)+chord(p1,p2);
      const approxC=(p0,p1,p2,p3)=>chord(p0,p1)+chord(p1,p2)+chord(p2,p3);
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
      const SQ=(p0,p1,p2,s)=>{for(let i=1;i<=s;i++){const t=i/s,mt=1-t; add({x:mt*mt*p0.x+2*mt*t*p1.x+t*t*p2.x,y:mt*mt*p0.y+2*mt*t*p1.y+t*t*p2.y});}};
      const SC=(p0,p1,p2,p3,s)=>{for(let i=1;i<=s;i++){const t=i/s,mt=1-t; add({x:mt*mt*mt*p0.x+3*mt*mt*t*p1.x+3*mt*t*t*p2.x+t*t*t*p3.x,y:mt*mt*mt*p0.y+3*mt*mt*t*p1.y+3*mt*t*t*p2.y+t*t*t*p3.y});}};
      for(const c of (otPath.commands||[])){
        if(c.type==='M'){ if(curr.length>2) polys.push(curr); curr=[]; pen={x:c.x,y:c.y}; start=pen; add(pen); }
        else if(c.type==='L'){ add({x:c.x,y:c.y}); pen={x:c.x,y:c.y}; }
        else if(c.type==='Q'){ const s=clamp(Math.ceil(approxQ(pen,{x:c.x1,y:c.y1},{x:c.x,y:c.y})/flatnessPx),6,64); SQ(pen,{x:c.x1,y:c.y1},{x:c.x,y:c.y},s); pen={x:c.x,y:c.y}; }
        else if(c.type==='C'){ const s=clamp(Math.ceil(approxC(pen,{x:c.x1,y:c.y1},{x:c.x2,y:c.y2},{x:c.x,y:c.y})/flatnessPx),10,96); SC(pen,{x:c.x1,y:c.y1},{x:c.x2,y:c.y2},{x:c.x,y:c.y},s); pen={x:c.x,y:c.y}; }
        else if(c.type==='Z'){ if(curr.length>2) polys.push(curr); curr=[]; pen=start; }
      }
      if(curr.length>2) polys.push(curr); return polys;
    }
    function makePolysFromText(font, text, fontSize, x, y, letterSpacing=0){
      if(!font||!text) return []; const glyphs=font.stringToGlyphs(text);
      const scale=fontSize/font.unitsPerEm; let cx=x; const all=[];
      for(let i=0;i<glyphs.length;i++){
        const g=glyphs[i], prev=i?glyphs[i-1]:null; if(prev) cx+=font.getKerningValue(prev,g)*scale;
        all.push(...otPathToPolys(g.getPath(cx,y,fontSize),0.6));
        cx+=(g.advanceWidth||font.unitsPerEm)*scale; if(i<glyphs.length-1) cx+=letterSpacing;
      }
      return all;
    }
    function polysUnionAndOffset(polys, delta, corner='round'){
      if(!Array.isArray(polys)||!polys.length||typeof ClipperLib==='undefined') return "";
      const S=1000, toI=pp=>pp.map(p=>({X:Math.round(p.X*S),Y:Math.round(p.Y*S)})), fromI=pp=>pp.map(p=>({x:p.X/S,y:p.Y/S}));
      let subj=polys.map(toI);
      subj=ClipperLib.Clipper.CleanPolygons(subj,0.1*S);
      subj=ClipperLib.Clipper.SimplifyPolygons(subj,ClipperLib.PolyFillType.pftEvenOdd);

      const c=new ClipperLib.Clipper();
      c.AddPaths(subj,ClipperLib.PolyType.ptSubject,true);
      const uni=[];
      c.Execute(ClipperLib.ClipType.ctUnion,uni,ClipperLib.PolyFillType.pftEvenOdd,ClipperLib.PolyFillType.pftEvenOdd);

      const joinType = (corner==='round') ? ClipperLib.JoinType.jtRound
                       : (corner==='miter') ? ClipperLib.JoinType.jtMiter
                       : ClipperLib.JoinType.jtSquare;

      const co=new ClipperLib.ClipperOffset(2.0,0.25*S);
      co.AddPaths(ClipperLib.Clipper.CleanPolygons(uni,0.08*S), joinType, ClipperLib.EndType.etClosedPolygon);

      const sol = [];
      const off = Math.round(Math.max(0, delta)*S); // delta în px
      co.Execute(sol, off);

      let d="";
      for(const path of ClipperLib.Clipper.CleanPolygons(sol,0.05*S)){
        const poly=fromI(path); if(poly.length<2) continue;
        d+=`M ${poly[0].x.toFixed(2)} ${poly[0].y.toFixed(2)} `;
        for(let i=1;i<poly.length;i++){ d+=`L ${poly[i].x.toFixed(2)} ${poly[i].y.toFixed(2)} `; }
        d+="Z ";
      }
      return d.trim();
    }

    function Preview({
      svgRef,
      paths,
      textBBox,
      colors,
      padMid,
      padBase,
      padTop,
      showTop,
      showMid,
      showBase,
      rounded,
      fontSizePx,
      setFontSizePx,
      lineData,
      lineOffsets,
      setLines,
      zoom,
      midExpanded,
      midExpandedD,
      baseExpanded,
      baseExpandedD,
      extraExpandedD,
      layerCount,
      extraMeta,
      stickers,
      onStickerDrag,
      onStickerSelect,
      setStickers,
      stickerDefs,
      selectedStickerIdx
    }) {
      const dragRef   = useRef({ active: false, index: -1, sx: 0, sy: 0, ox: 0, oy: 0 });
      const scaleRef  = useRef({ active: false, cx: 0, cy: 0, startDist: 1, startSize: fontSizePx });
      const anchorRef = useRef({ active: false, cx: 0, cy: 0 });
      const wheelTimerRef = useRef(null);

      const clientToSVG = useCallback((evt) => {
        const svg = svgRef?.current || null;
        if (!svg) return { x: 0, y: 0 };
        const pt = svg.createSVGPoint();
        pt.x = evt.clientX; pt.y = evt.clientY;
        const m = svg.getScreenCTM(); if (!m) return { x: 0, y: 0 };
        const inv = m.inverse(); const p = inv ? pt.matrixTransform(inv) : pt;
        return { x: p.x, y: p.y };
      }, [svgRef]);

      const onMove = useCallback((evt) => {
        if (!dragRef.current.active) return;
        evt.preventDefault();
        const { x, y } = clientToSVG(evt);
        const dx = Math.round(x - dragRef.current.sx);
        const dy = Math.round(y - dragRef.current.sy);
        const target = lineOffsets?.[dragRef.current.index];
        if (!target) return;
        if (target.setX) target.setX(dragRef.current.ox + dx);
        if (target.setY) target.setY(dragRef.current.oy + dy);
      }, [clientToSVG, lineOffsets]);

      const onUp = useCallback(() => {
        if (!dragRef.current.active) return;
        dragRef.current.active = false;
        dragRef.current.index = -1;
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
      }, [onMove]);

      const stickerDragRef = useRef({active:false, idx:-1, sx:0, sy:0, ox:0, oy:0});
      const stScaleRef = React.useRef({ active:false, idx:-1, cx:0, cy:0, startDist:1, startScale:1 });

      const onStickerMove = useCallback((evt) => {
        if(!stickerDragRef.current.active) return;
        evt.preventDefault();
        const { x, y } = clientToSVG(evt);
        const dx = Math.round(x - stickerDragRef.current.sx);
        const dy = Math.round(y - stickerDragRef.current.sy);
        const nx = stickerDragRef.current.ox + dx;
        const ny = stickerDragRef.current.oy + dy;
        if(typeof onStickerDrag === 'function') onStickerDrag(stickerDragRef.current.idx, nx, ny);
      }, [clientToSVG, onStickerDrag]);

      const onStickerUp = useCallback(() => {
        if(!stickerDragRef.current.active) return;
        stickerDragRef.current.active = false;
        window.removeEventListener('mousemove', onStickerMove);
        window.removeEventListener('mouseup', onStickerUp);
      }, [onStickerMove]);

      function stickerCorners(st, def){
        const w = (def?.bbox?.w || 100) * (st.scale || 1);
        const h = (def?.bbox?.h || 100) * (st.scale || 1);
        const minX = st.x - w/2, maxX = st.x + w/2;
        const minY = st.y - h/2, maxY = st.y + h/2;
        return { minX, minY, maxX, maxY, w, h, cx: st.x, cy: st.y };
      }

      const beginStickerScale = (evt, idx, st, def) => {
        evt.preventDefault(); evt.stopPropagation();
        const { cx, cy } = stickerCorners(st, def);
        const { x, y } = clientToSVG(evt);
        const dist = Math.hypot(x - cx, y - cy) || 1;
        stScaleRef.current = {
          active:true, idx, cx, cy,
          startDist: dist,
          startScale: st.scale || 1
        };
        window.addEventListener('mousemove', onStickerScaleMove);
        window.addEventListener('mouseup', onStickerScaleUp, { once:true });
      };

      const onStickerScaleMove = (evt) => {
        if(!stScaleRef.current.active) return;
        const { cx, cy, startDist, startScale, idx } = stScaleRef.current;
        const { x, y } = clientToSVG(evt);
        const dist = Math.hypot(x - cx, y - cy) || 1;
        let nextScale = startScale * (dist / startDist);
        nextScale = Math.max(0.05, Math.min(50, nextScale));
        if(typeof setStickers === 'function'){
          setStickers(prev => prev.map((it,i)=> i===idx ? {...it, scale: nextScale} : it));
        }
      };

      const onStickerScaleUp = () => {
        stScaleRef.current.active = false;
        window.removeEventListener('mousemove', onStickerScaleMove);
        window.removeEventListener('mouseup', onStickerScaleUp);
      };

      const beginStickerDrag = useCallback((evt, idx, x0, y0) => {
        evt.preventDefault();
        const { x, y } = clientToSVG(evt);
        stickerDragRef.current = { active:true, idx, sx:x, sy:y, ox:x0, oy:y0 };
        window.addEventListener('mousemove', onStickerMove);
        window.addEventListener('mouseup', onStickerUp, { once:true });
      }, [clientToSVG, onStickerMove, onStickerUp]);

      const beginDrag = useCallback((evt, idx) => {
        const target = lineOffsets?.[idx];
        if (!target) return;
        evt.preventDefault();
        const { x, y } = clientToSVG(evt);
        dragRef.current = {
          active: true,
          index: idx,
          sx: x,
          sy: y,
          ox: target.x || 0,
          oy: target.y || 0
        };
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp, { once: true });
      }, [clientToSVG, lineOffsets, onMove, onUp]);

      const centerFromBBox = (bb) => bb ? {
        cx: (bb.minX + bb.maxX) / 2,
        cy: (bb.minY + bb.maxY) / 2
      } : null;

      const scaleCenter = useMemo(() => centerFromBBox(textBBox), [textBBox]);

      const onScaleMove = useCallback((evt) => {
        if (!scaleRef.current.active) return;
        evt.preventDefault();
        const { x, y } = clientToSVG(evt);
        const distance = Math.hypot(x - scaleRef.current.cx, y - scaleRef.current.cy) || 1;
        let ratio = distance / scaleRef.current.startDist;
        if (evt.shiftKey) ratio = 1 + (ratio - 1) * 0.35;
        let next = scaleRef.current.startSize * ratio;
        next = Math.max(20, Math.min(5000, next));
        setFontSizePx(Math.round(next));
      }, [clientToSVG, setFontSizePx]);

      const onScaleUp = useCallback(() => {
        if (!scaleRef.current.active) return;
        scaleRef.current.active = false;
        window.removeEventListener('mousemove', onScaleMove);
        window.removeEventListener('mouseup', onScaleUp);
        anchorRef.current.active = false;
      }, [onScaleMove]);

      const onScaleDown = useCallback((evt) => {
        if (!textBBox || !scaleCenter) return;
        evt.preventDefault(); evt.stopPropagation();
        const { x, y } = clientToSVG(evt);
        const dist = Math.hypot(x - scaleCenter.cx, y - scaleCenter.cy) || 1;
        scaleRef.current = {
          active: true, cx: scaleCenter.cx, cy: scaleCenter.cy,
          startDist: dist, startSize: fontSizePx
        };
        anchorRef.current = { active: true, cx: scaleCenter.cx, cy: scaleCenter.cy };
        window.addEventListener('mousemove', onScaleMove);
        window.addEventListener('mouseup', onScaleUp, { once: true });
      }, [clientToSVG, fontSizePx, onScaleMove, onScaleUp, scaleCenter, textBBox]);

      // Ctrl+Wheel zoom
      useEffect(() => {
        const svg = svgRef.current;
        if (!svg) return;
        const onWheel = (e) => {
          if (!e.ctrlKey || !textBBox) return;
          e.preventDefault();
          const c = centerFromBBox(textBBox);
          if (!anchorRef.current.active && c) anchorRef.current = { active: true, cx: c.cx, cy: c.cy };
          const zoomIn = e.deltaY < 0;
          const base = zoomIn ? 1.12 : (1 / 1.12);
          const factor = e.shiftKey ? (1 + (base - 1) * 0.35) : base;
          let next = fontSizePx * factor;
          next = Math.max(20, Math.min(5000, next));
          setFontSizePx(Math.round(next));
          if (wheelTimerRef.current) clearTimeout(wheelTimerRef.current);
          wheelTimerRef.current = setTimeout(() => { anchorRef.current.active = false; }, 200);
        };
        svg.addEventListener('wheel', onWheel, { passive: false });
        return () => {
          svg.removeEventListener('wheel', onWheel);
          if (wheelTimerRef.current) clearTimeout(wheelTimerRef.current);
        };
      }, [fontSizePx, textBBox, setFontSizePx]);

      // Re-centrare după scale (un singur setLines batched – evită loop)
      useEffect(() => {
        if (!anchorRef.current.active || !textBBox) return;
        const c = centerFromBBox(textBBox);
        if (!c) return;
        const dx = anchorRef.current.cx - c.cx;
        const dy = anchorRef.current.cy - c.cy;
        if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
          if (typeof setLines === 'function') {
            setLines(prev => {
              const out = prev && typeof prev === 'object' ? { ...prev } : {};
              ['line1','line2','line3'].forEach(k => {
                const cur = out[k] || {};
                out[k] = { ...cur, x: (cur.x || 0) + dx, y: (cur.y || 0) + dy };
              });
              return out;
            });
          }
        }
      }, [textBBox, setLines]);

      const lineJoin = rounded ? "round" : "miter";
      // grosimi pe layer, controlate din UI
      const midStroke  = Math.max(1, Math.round(padMid  || 0));
      const baseStroke = Math.max(1, Math.round(padBase || 0));
      const topStroke  = Math.max(0, Math.round(padTop  || 0)); // 0 = fără contur
      const { base = "#111827", mid = "#ef4444", top = "#ffffff" } = colors || {};
      const showHandle = Boolean(paths && paths.length && textBBox);

      return React.createElement(
        "svg",
        {
          ref: svgRef, xmlns: "http://www.w3.org/2000/svg",
          width: "100%", height: "100%",
          viewBox: `0 0 ${DESIGN_W} ${DESIGN_H}`,
          preserveAspectRatio: "xMidYMid meet",
          className: "svg-preview",
          onMouseLeave: onUp
        },
        // crosshair (nu se scalează cu zoom)
        React.createElement("line", { x1: DESIGN_W/2, y1: 0, x2: DESIGN_W/2, y2: DESIGN_H, stroke: "#cbd5e1", strokeWidth: 1 }),
        React.createElement("line", { x1: 0, y1: DESIGN_H/2, x2: DESIGN_W, y2: DESIGN_H/2, stroke: "#cbd5e1", strokeWidth: 1 }),

        // conținutul scalat: traducem față de centrul canvasului ca să rămână fix în mijloc
        React.createElement("g", {
          key: "zoomwrap",
          transform: `translate(${(DESIGN_W/2)*(1-zoom)}, ${(DESIGN_H/2)*(1-zoom)}) scale(${zoom})`
        }, [
          // === LAYERE DINAMICE — ORDIN: EXTERIOR -> INTERIOR, cu TOP la FINAL ===
 
          // 1) BASE (dacă layerCount >= 2)
          ...((layerCount >= 2 && showBase) ? (
            baseExpanded && baseExpandedD
              ? [ React.createElement("path", { key:"base-expanded", d: baseExpandedD, fill: (colors?.base || "#111827") }) ]
              : (paths || []).map((d, i) => [
                  React.createElement("path", { key:`base-fill-${i}`, d, fill:(colors?.base || "#111827") }),
                  React.createElement("path", {
                    key:`base-stroke-${i}`, d, fill:"none",
                    stroke:(colors?.base || "#111827"),
                    strokeWidth: Math.max(1, Math.round(padBase || 0)),
                    strokeLinejoin: (rounded ? "round" : "miter"),
                    strokeLinecap:  (rounded ? "round" : "butt")
                  })
                ]).flat()
          ) : []),
 
          // 2) EXTRA (dacă layerCount > 3) — EXTERIOR -> INTERIOR
          ...((layerCount > 3 && extraExpandedD && extraExpandedD.length)
            ? extraExpandedD.map((d, idx) => {
                const meta = (extraMeta && extraMeta[idx]) || {};
                if (meta.show === false) return null;
                return React.createElement("path", {
                  key:`extra-${idx}`,
                  d,
                  fill: meta.color || (colors?.base || "#111827")
                });
              }).filter(Boolean)
            : []),
 
          // 3) MID (dacă layerCount >= 3)
          ...((layerCount >= 3 && showMid) ? (
            midExpanded && midExpandedD
              ? [ React.createElement("path", { key:"mid-expanded", d: midExpandedD, fill: (colors?.mid || "#ef4444") }) ]
              : (paths || []).map((d, i) => [
                  React.createElement("path", { key:`mid-fill-${i}`, d, fill:(colors?.mid || "#ef4444") }),
                  React.createElement("path", {
                    key:`mid-stroke-${i}`, d, fill:"none",
                    stroke:(colors?.mid || "#ef4444"),
                    strokeWidth: Math.max(1, Math.round(padMid || 0)),
                    strokeLinejoin: (rounded ? "round" : "miter"),
                    strokeLinecap:  (rounded ? "round" : "butt")
                  })
                ]).flat()
          ) : []),
 
          // ==== STICKERE ====
          ...(Array.isArray(stickers) ? stickers.map((st, idx) => {
            const def = stickerDefs?.find(d => d.id === st.type);
            if(!def) return null;
            // corpul stickerului (îl plasezi printr-un <g> cu translate/scale/rotate)
            const pieces = renderStickerLayers(st, def, idx);
            // selection
            if (idx === selectedStickerIdx) {
              pieces.push(React.createElement("path", {
                key:"s", d: def.d, fill:"none", stroke:"#3b82f6", strokeWidth:0.6 / Math.max(0.1, st.scale||1)
              }));
            }
            const g = React.createElement("g", {
              key:`st-${idx}`,
              transform: `translate(${st.x},${st.y}) rotate(${st.rotation||0}) scale(${st.scale||1})`,
              style: { cursor:"move" },
              onMouseDown: (e) => {
                if(typeof onStickerSelect === 'function') onStickerSelect(idx);
                beginStickerDrag(e, idx, st.x, st.y);
              },
              onClick: (e) => { e.stopPropagation(); if(typeof onStickerSelect === 'function') onStickerSelect(idx); }
            }, pieces);
            // handle-ul (bulina neagră) – la colțul dreapta-jos al bbox-ului axis-aligned
            const { maxX, maxY } = stickerCorners(st, def);
            const handle = idx === selectedStickerIdx ? React.createElement("circle", {
              key:`st-h-${idx}`,
              cx: maxX, cy: maxY, r: 10,
              fill: "#111827", stroke: "#fff", strokeWidth: 2,
              style: { cursor:"nwse-resize" },
              onMouseDown: (e) => beginStickerScale(e, idx, st, def)
            }) : null;
            return React.createElement(React.Fragment, { key:`st-wrap-${idx}` }, [g, handle].filter(Boolean));
          }) : []),

          // 4) TOP — ULTIMUL, ca să fie VIZIBIL deasupra
          ...(showTop ? (paths || []).map((d, i) =>
            React.createElement("path", { key: `top-${i}`, d, fill: (colors?.top || "#ffffff") })
          ) : []),

          // zone drag pe fiecare rând
          ...(lineData || []).map((line) => React.createElement("path", {
            key: `drag-${line.index}`,
            d: line.d, fill: "transparent", stroke: "transparent", strokeWidth: 20,
            style: { cursor: "move" }, onMouseDown: (evt) => beginDrag(evt, line.index)
          })),

          // handle scale
          showHandle ? React.createElement("circle", {
            key: "scale", cx: textBBox.maxX, cy: textBBox.maxY, r: 14,
            fill: base, stroke: "#ffffff", strokeWidth: 2,
            style: { cursor: "nwse-resize" }, onMouseDown: onScaleDown
          }) : null
        ])
      );
    }

    /* mic helper pentru iconița ochi / ochi-tăiat */
    function EyeIcon(visible){
      return React.createElement("svg", {
        width:18, height:18, viewBox:"0 0 24 24", fill:"none",
        stroke:"currentColor", strokeWidth:2, strokeLinecap:"round", strokeLinejoin:"round"
      }, [
        React.createElement("path", { key:"p", d:"M1 12s4-7 11-7 11 7 11 7-4 7-11 7-11-7-11-7z" }),
        React.createElement("circle", { key:"c", cx:12, cy:12, r:3 }),
        visible ? null : React.createElement("line", { key:"l", x1:3, y1:3, x2:21, y2:21 })
      ]);
    }

    function SizeDial({
      value, onChange,
      min=0.1, max=50,
      step=0.1, bigStep=1,
      size=56, title="Mărime"
    }){
      const dragRef = React.useRef({active:false, startY:0, startV:0});
      const clampV = v => Math.min(max, Math.max(min, v));
      const commit = v => typeof onChange==="function" && onChange(clampV(v));
    
      const onDown = e => {
        e.preventDefault();
        dragRef.current = {active:true, startY:e.clientY, startV:value};
        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp, {once:true});
      };
      const onMove = e => {
        if(!dragRef.current.active) return;
        const dy = dragRef.current.startY - e.clientY;   // sus=+
        commit(dragRef.current.startV + (dy/30)*bigStep);
      };
      const onUp = () => {
        dragRef.current.active = false;
        window.removeEventListener("mousemove", onMove);
        window.removeEventListener("mouseup", onUp);
      };
      const onWheel = e => {
        e.preventDefault();
        const inc = e.shiftKey ? bigStep : step;
        commit(value + (e.deltaY < 0 ? +inc : -inc));
      };
      const nudge = dv => e => {
        e.stopPropagation();
        commit(value + (e.shiftKey ? dv*bigStep : dv*step));
      };
    
      const s=size, c=s/2, r=c-2;
      return React.createElement("div", {title, style:{display:"flex",gap:10,alignItems:"center",userSelect:"none"}}, [
        React.createElement("svg", {
          key:"dial", width:s, height:s, viewBox:`0 0 ${s} ${s}`,
          onMouseDown:onDown, onWheel:onWheel, style:{cursor:"ns-resize"}
        }, [
          React.createElement("circle",{key:"bg",cx:c,cy:c,r:r,fill:"#111827",stroke:"#0a0a0a"}),
          React.createElement("path",{key:"up",   d:`M ${c} 8 l 8 10 h -16 z`, fill:"#fff", onClick:nudge(+1)}),
          React.createElement("path",{key:"down", d:`M ${c} ${s-8} l -8 -10 h 16 z`, fill:"#fff", onClick:nudge(-1)}),
          React.createElement("path",{key:"left", d:`M 8 ${c} l 10 -8 v 16 z`, fill:"#fff", onClick:nudge(-1)}),
          React.createElement("path",{key:"right",d:`M ${s-8} ${c} l -10 8 v -16 z`, fill:"#fff", onClick:nudge(+1)}),
          React.createElement("text",{key:"t",x:c,y:c+4,textAnchor:"middle",fontSize:10,fill:"#fff"}, `${value}`)
        ]),
        React.createElement("input",{
          key:"num", type:"number", step:step, min:min, max:max,
          value: isNaN(value) ? "" : value,
          onChange:e=>commit(parseFloat(e.target.value||value))
        })
      ]);
    }

    function App(){
      // STATE
      const [fontSizePx, setFontSizePx] = useState(140);
      const [selectedLineId, setSelectedLineId] = useState('line1');
      const [lines, setLines] = useState({
        line1: { x: 0, y: 0 }, line2: { x: 0, y: 0 }, line3: { x: 0, y: 0 }
      });

      // Fonts
      const [fonts, setFonts] = useState([]);
      const [fontId, setFontId] = useState("");
      const [font, setFont] = useState(null);
      const [loadMsg, setLoadMsg] = useState("");
      
      // === Stickere (bibliotecă + instanțe pe canvas) ===
      const [stickersLib, setStickersLib] = useState([]);
      const [stickers, setStickers] = useState([]);        // [{type:'star', x,y, scale, rotation, layerCount, layers:{...}}, ...]
      const [selectedStickerIdx, setSelectedStickerIdx] = useState(-1);  // index-ul din 'stickers' sau -1 dacă nimic selectat

      // Text (până la 3 rânduri)
      const [text, setText]   = useState("Marius");
      const [text2, setText2] = useState("");
      const [text3, setText3] = useState("");

      // Layout
      const [lineSpacing, setLineSpacing] = useState(0.95);
      const [letterSpacing, setLetterSpacing] = useState(0);

      // Culori & look
      const [cTop, setCTop]   = useState("#ffffff");
      const [cMid, setCMid]   = useState("#ef4444");
      const [cBase, setCBase] = useState("#111827");
      // Grosimi per layer
      const [padMid, setPadMid]   = useState(16); // default aprox. 0.55 * 28
      const [padBase, setPadBase] = useState(28);
      // grosimi "înghețate" la apăsarea Set
      const [midExpandedPad, setMidExpandedPad] = useState(null);
      const [baseExpandedPad, setBaseExpandedPad] = useState(null);
      // KILO test flag (doar pentru verificare patch)
      const [midExpandedTest, setMidExpandedTest] = React.useState(false);
      function applyExpandMiddleTest(){
        console.log("KILO TEST: Set clicked");
        setMidExpandedTest(true);
      }
      const [padTop,  setPadTop]  = useState(0);
      const [round, setRound] = useState(true);
      // Vizibilitate layere (există deja în export; ne asigurăm că sunt în stare și folosite în Preview)
      const [showTop, setShowTop]   = useState(() => { try { return JSON.parse(localStorage.getItem('showTop')  ?? 'true'); } catch(_) { return true; } });
      const [showMid, setShowMid]   = useState(() => { try { return JSON.parse(localStorage.getItem('showMid')  ?? 'true'); } catch(_) { return true; } });
      const [showBase, setShowBase] = useState(() => { try { return JSON.parse(localStorage.getItem('showBase') ?? 'true'); } catch(_) { return true; } });
      useEffect(()=>{ try{ localStorage.setItem('showTop',  JSON.stringify(showTop)); }catch(_){}} ,[showTop]);
      useEffect(()=>{ try{ localStorage.setItem('showMid',  JSON.stringify(showMid)); }catch(_){}} ,[showMid]);
      useEffect(()=>{ try{ localStorage.setItem('showBase', JSON.stringify(showBase)); }catch(_){}} ,[showBase]);

      // Expand flags (controlate din butoanele Set)
      const [midExpanded, setMidExpanded]   = useState(false);
      const [baseExpanded, setBaseExpanded] = useState(false);
      // Layere intermediare (max 2): [Layer 4, Layer 5]
      const [extraLayers, setExtraLayers] = useState([
        { id: 4, pad: Math.round((28*2 + 16)/3), color: "#9ca3af", show: true, expanded: true },
        { id: 5, pad: Math.round((28 + 16*2)/3), color: "#6b7280", show: true, expanded: true }
      ]);
      const [layerCount, setLayerCount] = useState(3);
      // === Zoom de preview (10% - 200%) + Fit ===
      const [zoom, setZoom] = useState(() => {
        try { return Number(localStorage.getItem('previewZoom')) || 1; } catch(_) { return 1; }
      });
      useEffect(() => { try { localStorage.setItem('previewZoom', String(zoom)); } catch(_) {} }, [zoom]);
      // === Unități transform (trebuie DEFINIT devreme, e folosit de snapshot/undo) ===
      const [unit, setUnit] = React.useState(() => {
        try { return localStorage.getItem('transformUnit') || 'px'; } catch(_) { return 'px'; }
      });
      React.useEffect(() => { try { localStorage.setItem('transformUnit', unit); } catch(_) {} }, [unit]);
  
      const getSnapshot = useCallback(() => ({
        text, text2, text3, fontSizePx, selectedLineId, lines, fontId, stickers, selectedStickerIdx, lineSpacing, letterSpacing, cTop, cMid, cBase, padMid, padBase, midExpandedPad, baseExpandedPad, padTop, round, showTop, showMid, showBase, midExpanded, baseExpanded, extraLayers, layerCount, zoom, unit
      }), [text, text2, text3, fontSizePx, selectedLineId, lines, fontId, stickers, selectedStickerIdx, lineSpacing, letterSpacing, cTop, cMid, cBase, padMid, padBase, midExpandedPad, baseExpandedPad, padTop, round, showTop, showMid, showBase, midExpanded, baseExpanded, extraLayers, layerCount, zoom, unit]);
  
      const applySnapshot = useCallback((snap) => {
        setFontSizePx(snap.fontSizePx);
        setLines(snap.lines || { line1:{x:0,y:0}, line2:{x:0,y:0}, line3:{x:0,y:0} });
        setText(snap.text); setText2(snap.text2); setText3(snap.text3);
        setLineSpacing(snap.lineSpacing); setLetterSpacing(snap.letterSpacing);
        setCTop(snap.cTop); setCMid(snap.cMid); setCBase(snap.cBase);
        setPadMid(snap.padMid); setPadBase(snap.padBase); setPadTop(snap.padTop);
        setRound(snap.round);
        setShowTop(snap.showTop); setShowMid(snap.showMid); setShowBase(snap.showBase);
        setMidExpanded(snap.midExpanded); setBaseExpanded(snap.baseExpanded);
        setMidExpandedPad(snap.midExpandedPad); setBaseExpandedPad(snap.baseExpandedPad);
        setExtraLayers(snap.extraLayers); setLayerCount(snap.layerCount);
        setStickers(snap.stickers); setSelectedStickerIdx(snap.selectedStickerIdx);
        setZoom(snap.zoom); setUnit(snap.unit);
      }, []);
  
      useEffect(() => {
        window.getSnapshot = getSnapshot;
        window.applySnapshot = applySnapshot;

        // Capturează snapshot-ul complet la primul mount și folosește-l ca defaults
        if (!window.__LCS_BOOT_SNAPSHOT__) {
          try {
            const boot = getSnapshot();
            window.__LCS_BOOT_SNAPSHOT__ = boot;
            if (window.LCS && window.LCS.defaults !== undefined) {
              // suprascriem defaults ca să includă TOT ce ai în app
              window.LCS.defaults = (typeof structuredClone === 'function')
                ? structuredClone(boot)
                : JSON.parse(JSON.stringify(boot));
            }
          } catch (_) {}
        }
      }, [getSnapshot, applySnapshot]);
      
      function addStickerToCanvas(st){
        if(!st) return;
        setStickers(prev => {
          const next = prev.concat([{
            type: st.id,
            x: DESIGN_W/2, y: DESIGN_H/2,
            scale: 1, rotation: 0,
            color: "#111827",
            layerCount: 3,
            layers: {
              top:  { color: "#111827", show: true,  pad: 0  },
              mid:  { color: "#ef4444", show: true,  pad: 16 },
              base: { color: "#111827", show: true,  pad: 28 },
              extras: [
                { color: "#9ca3af", show: true, pad: 22 }, // L4
                { color: "#6b7280", show: true, pad: 18 }  // L5
              ],
              rounded: true
            }
          }]);
          setSelectedStickerIdx(next.length - 1);
          return next;
        });
        pushHistory();
      }

      useEffect(() => {
        window.applyExpandMid   = () => { setMidExpandedPad(padMid);  setMidExpanded(true);  };
        window.resetExpandMid   = () => { setMidExpandedPad(null);    setMidExpanded(false); };

        window.applyExpandBase  = () => { setBaseExpandedPad(padBase); setBaseExpanded(true); };
        window.resetExpandBase  = () => { setBaseExpandedPad(null);    setBaseExpanded(false); };

        return () => {
          delete window.applyExpandMid;
          delete window.resetExpandMid;
          delete window.applyExpandBase;
          delete window.resetExpandBase;
        };
      }, [padMid, padBase]);

      // când modifici numărul total de layere, păstrăm doar primele (dacă e cazul)
      useEffect(() => {
        const need = Math.max(0, Math.min(2, layerCount - 3));
        if (extraLayers.length !== 2 || need === 2) return; // avem deja 2, sau nu trebuie tăiat
        setExtraLayers(prev => prev.slice(0, need || 0).concat(Array(need - (prev.slice(0, need).length)).fill(null).map((_,i)=>({
          id: 4 + i, pad: Math.round((padBase + padMid)/2), color: "#9ca3af", show: true, expanded: true
        }))));
      }, [layerCount]); // intenționat doar la schimbarea layerCount

      const scale = useMemo(() => fontSizePx / 100, [fontSizePx]);

      // HUD
      const hudFontLabel = useMemo(() => {
        const it = fonts.find(f => (f.id ?? f.file) === fontId);
        return it?.label || it?.id || it?.file || "(fără font)";
      }, [fonts, fontId]);
      useEffect(() => {
        const linesCount = [text, text2, text3].filter(Boolean).length;
        if (window.__setHUD) window.__setHUD(`Font: ${hudFontLabel} • Size: ${fontSizePx}px • Linii: ${linesCount}`);
      }, [hudFontLabel, fontSizePx, text, text2, text3]);

      // Load fonts list
      useEffect(() => {
        (async () => {
          try {
            const list = await loadFontsList();
            setFonts(list);
            if (list.length) setFontId(list[0].id ?? list[0].file);
          } catch (e) {
            setLoadMsg("Nu pot încărca fonts.json ("+e.message+")");
          }
        })();
      }, []);
      
      // Load stickers
      useEffect(() => { loadStickers().then(setStickersLib); }, []);

      // Sync sticker selection
      useEffect(() => {
        setStickers(prev => prev.map((it, i) => ({ ...it, selected: i===selectedStickerIdx })));
      }, [selectedStickerIdx]);

      // Load selected font
      useEffect(() => {
        let stop = false;
        (async () => {
          const it = fonts.find(f => (f.id ?? f.file) === fontId);
          if (!it) { setFont(null); return; }
          try {
            setLoadMsg("Se încarcă fontul...");
            const f = await loadFontFile(it.file);
            if (!stop) { setFont(f); setLoadMsg(""); }
          } catch (e) {
            if (!stop) { setFont(null); setLoadMsg("Eroare font: " + e.message); }
          }
        })();
        return () => { stop = true; };
      }, [fontId, fonts]);

      // Layout (paths/bbox/lines)
      const layout = useMemo(() => {
        if (!font) return { paths: [], bbox: null, lines: [] };
        const rawLines = [text, text2, text3].filter(Boolean);
        if (!rawLines.length) return { paths: [], bbox: null, lines: [] };

        const spacing = Number.isFinite(lineSpacing) && lineSpacing > 0 ? lineSpacing : 1;
        const totalHeight = fontSizePx + (rawLines.length - 1) * fontSizePx * spacing;
        const baselineTop = DESIGN_H / 2 - totalHeight / 2;

        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        const perLine = [];
        const offsets = [
          lines.line1 || { x: 0, y: 0 },
          lines.line2 || { x: 0, y: 0 },
          lines.line3 || { x: 0, y: 0 }
        ];

        for (let idx = 0; idx < rawLines.length; idx++) {
          const value = rawLines[idx];
          const glyphs = font.stringToGlyphs(value);
          if (!glyphs.length) continue;

          const scale = fontSizePx / font.unitsPerEm;
          let width = 0, prev = null;
          for (let i = 0; i < glyphs.length; i++) {
            const g = glyphs[i];
            if (prev) width += font.getKerningValue(prev, g) * scale;
            width += (g.advanceWidth || font.unitsPerEm) * scale;
            if (i < glyphs.length - 1) width += letterSpacing;
            prev = g;
          }

          const baseLine = baselineTop + fontSizePx + idx * fontSizePx * spacing;
          const off = offsets[idx] || { x: 0, y: 0 };
          const y = Math.round(baseLine) + off.y;
          const x = DESIGN_W / 2 - width / 2 + off.x;

          const { d, bbox } = makePathFromText(font, value, fontSizePx, x, y, letterSpacing, glyphs);
          if (!d) continue;

          perLine.push({ d, bbox, index: idx, x, y, value });

          if (bbox) {
            if (bbox.minX < minX) minX = bbox.minX;
            if (bbox.minY < minY) minY = bbox.minY;
            if (bbox.maxX > maxX) maxX = bbox.maxX;
            if (bbox.maxY > maxY) maxY = bbox.maxY;
          }
        }

        const allPolys = perLine.flatMap(line =>
          makePolysFromText(font, line.value, fontSizePx, line.x, line.y, letterSpacing)
        );

        // Deltele trebuie să fie stroke-ul REAL/2.
        // Tipul de colț trebuie să fie în acord cu „Rotunjit”.
        const midStroke  = Math.max(1, Math.round(padMid  || 0));
        const baseStroke = Math.max(1, Math.round(padBase || 0));
        const cornerType = (round ? 'round' : 'miter');

        const expandD = (deltaPx) => polysUnionAndOffset(allPolys, deltaPx, cornerType);

        const midExpandedD  = expandD(((midExpandedPad  != null) ? midExpandedPad  : midStroke)  * 0.5);
        const baseExpandedD = expandD(((baseExpandedPad != null) ? baseExpandedPad : baseStroke) * 0.5);

        const exCount = Math.max(0, Math.min(2, layerCount - 3));
        const extrasUsed = extraLayers.slice(0, exCount);
        const extraExpandedD = extrasUsed.map(ex => {
          const strokeW = Math.max(1, Math.round(ex.pad || 0));
          return expandD(strokeW * 0.5);
        });

        const hasBox = Number.isFinite(minX) && Number.isFinite(minY) && Number.isFinite(maxX) && Number.isFinite(maxY);
        const paths = perLine.map(line => line.d);
        return { paths, bbox: hasBox ? { minX, minY, maxX, maxY } : null, lines: perLine, midExpandedD, baseExpandedD, extraExpandedD };
      }, [
        font, text, text2, text3,
        fontSizePx, lines, lineSpacing, letterSpacing,
        layerCount, round,
        padMid, padBase,                 // <- slider-ele
        midExpandedPad, baseExpandedPad, // <- valorile "înghețate" la Set
        extraLayers                      // <- dacă ai 4/5 layere
      ]);

      const { paths, bbox: textBBox, lines: lineData, midExpandedD, baseExpandedD, extraExpandedD } = layout;
      const svgRef = useRef(null);
      const previewColors = useMemo(() => ({ top: cTop, mid: cMid, base: cBase }), [cTop, cMid, cBase]);




      const fitZoom = React.useCallback(() => {
        if (!textBBox) return;
        const w = (textBBox.maxX - textBBox.minX);
        const h = (textBBox.maxY - textBBox.minY);
        if (!(w>0 && h>0)) return;
        const margin = 40; // px de margine vizuală
        const zx = (DESIGN_W - margin) / w;
        const zy = (DESIGN_H - margin) / h;
        const z = clamp(Math.min(zx, zy), 0.05, 2);
        setZoom(z);
      }, [textBBox]);
      const resetZoom = React.useCallback(() => setZoom(1), []);

      // === TRANSFORM (X, Y, W, H) – poziție și dimensiune pe bbox ===
      const curBBox = textBBox;
      const curW = useMemo(() => curBBox ? (curBBox.maxX - curBBox.minX) : 0, [curBBox]);
      const curH = useMemo(() => curBBox ? (curBBox.maxY - curBBox.minY) : 0, [curBBox]);
      const curCX = useMemo(() => curBBox ? (curBBox.minX + curBBox.maxX)/2 : 0, [curBBox]);
      const curCY = useMemo(() => curBBox ? (curBBox.minY + curBBox.maxY)/2 : 0, [curBBox]);

      /* ===== Unități pentru Transform (px / mm / cm / in) ===== */
      const PX_PER_IN = 96;
      const PX_PER_MM = PX_PER_IN / 25.4;
      const PX_PER_CM = PX_PER_IN / 2.54;
      const pxToUnit = React.useCallback((px, u) => {
        if (!Number.isFinite(px)) return NaN;
        switch(u){
          case 'mm': return px / PX_PER_MM;
          case 'cm': return px / PX_PER_CM;
          case 'in': return px / PX_PER_IN;
          default:   return px; // px
        }
      }, []);
      const unitToPx = React.useCallback((v, u) => {
        const n = toNum(v, NaN);
        if (!Number.isFinite(n)) return NaN;
        switch(u){
          case 'mm': return n * PX_PER_MM;
          case 'cm': return n * PX_PER_CM;
          case 'in': return n * PX_PER_IN;
          default:   return n; // px
        }
      }, []);
      const stepByUnit = { px: 1, mm: 0.1, cm: 0.01, in: 0.001 };
      const digits = (unit === 'px') ? 0 : 2;
      // valori afișate în UI (convertite)
      const dispX = curBBox ? fixed(pxToUnit(curCX, unit), digits) : "";
      const dispY = curBBox ? fixed(pxToUnit(curCY, unit), digits) : "";
      const dispW = curBBox ? fixed(pxToUnit(curW,  unit), digits) : "";
      const dispH = curBBox ? fixed(pxToUnit(curH,  unit), digits) : "";
      // handler-e care acceptă valori în unitatea curentă
      const onXChangeU = (e) => {
        const vpx = unitToPx(e.target.value, unit);
        if (Number.isFinite(vpx)) moveToCenter(vpx, curCY);
      };
      const onYChangeU = (e) => {
        const vpx = unitToPx(e.target.value, unit);
        if (Number.isFinite(vpx)) moveToCenter(curCX, vpx);
      };
      const onWChangeU = (e) => {
        const vpx = unitToPx(e.target.value, unit);
        if (curW > 0 && Number.isFinite(vpx)) scaleUniformBy(vpx / curW);
      };
      const onHChangeU = (e) => {
        const vpx = unitToPx(e.target.value, unit);
        if (curH > 0 && Number.isFinite(vpx)) scaleUniformBy(vpx / curH);
      };

      const moveToCenter = React.useCallback((nx, ny) => {
        if (!curBBox) return;
        const dx = (nx ?? curCX) - curCX;
        const dy = (ny ?? curCY) - curCY;
        if (Math.abs(dx) < 0.001 && Math.abs(dy) < 0.001) return;
        setLines(prev => ({
          line1: { ...(prev.line1 || {}), x: (prev.line1?.x||0) + dx, y: (prev.line1?.y||0) + dy },
          line2: { ...(prev.line2 || {}), x: (prev.line2?.x||0) + dx, y: (prev.line2?.y||0) + dy },
          line3: { ...(prev.line3 || {}), x: (prev.line3?.x||0) + dx, y: (prev.line3?.y||0) + dy },
        }));
        pushHistory();
      }, [curBBox, curCX, curCY, setLines]);

      const scaleUniformBy = React.useCallback((factor) => {
        if (!Number.isFinite(factor) || factor <= 0) return;
        const next = clamp(Math.round(fontSizePx * factor), 8, 5000);
        setFontSizePx(next);
        pushHistory();
        // centrul rămâne neschimbat (layout-ul nostru e centrat pe orizontală),
        // dar ca să fim siguri, re-fixăm centrul la valoarea curentă
        // după ce se actualizează bbox-ul (într-un micro-task).
        setTimeout(() => moveToCenter(curCX, curCY), 0);
      }, [fontSizePx, moveToCenter, curCX, curCY, setFontSizePx]);

      const onXChange = (e) => {
        const v = toNum(e.target.value, curCX);
        moveToCenter(v, curCY);
      };
      const onYChange = (e) => {
        const v = toNum(e.target.value, curCY);
        moveToCenter(curCX, v);
      };
      const onWChange = (e) => {
        const v = toNum(e.target.value, curW);
        if (curW > 0) scaleUniformBy(v / curW);
      };
      const onHChange = (e) => {
        const v = toNum(e.target.value, curH);
        if (curH > 0) scaleUniformBy(v / curH);
      };

      const lineOffsets = useMemo(() => ([
        { x: lines.line1?.x || 0, y: lines.line1?.y || 0, setX: (v) => setLines(prev => ({ ...prev, line1: { ...prev.line1 || {}, x: v } })), setY: (v) => setLines(prev => ({ ...prev, line1: { ...prev.line1 || {}, y: v } })) },
        { x: lines.line2?.x || 0, y: lines.line2?.y || 0, setX: (v) => setLines(prev => ({ ...prev, line2: { ...prev.line2 || {}, x: v } })), setY: (v) => setLines(prev => ({ ...prev, line2: { ...prev.line2 || {}, y: v } })) },
        { x: lines.line3?.x || 0, y: lines.line3?.y || 0, setX: (v) => setLines(prev => ({ ...prev, line3: { ...prev.line3 || {}, x: v } })), setY: (v) => setLines(prev => ({ ...prev, line3: { ...prev.line3 || {}, y: v } })) }
      ]), [lines, setLines]);

      // Export SVG
      function downloadSVG(){
        if (!paths || !paths.length) return;
        const lineJoin = round ? "round" : "miter";
        const lineCap  = round ? "round" : "butt";
        const midStroke  = Math.max(1, Math.round(padMid  || 0));
        const baseStroke = Math.max(1, Math.round(padBase || 0));
        const topStroke  = Math.max(0, Math.round(padTop  || 0));
        const outlineMid = false;
        const outlineBase = false;
        // respectă vizibilitatea: showTop/showMid/showBase
        let out = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${DESIGN_W} ${DESIGN_H}" width="${DESIGN_W}" height="${DESIGN_H}">`;

        // BASE
        if (layerCount >= 2 && showBase) {
          if (baseExpanded && baseExpandedD) {
            out += `<path d="${baseExpandedD}" fill="${cBase}"/>`;
          } else {
            (paths||[]).forEach(d=>{
              out += `<path d="${d}" fill="${cBase}"/>`;
              out += `<path d="${d}" fill="none" stroke="${cBase}" stroke-width="${Math.max(1, Math.round(padBase||0))}" stroke-linejoin="${round ? "round":"miter"}" stroke-linecap="${round ? "round":"butt"}"/>`;
            });
          }
        }

        // EXTRA (dacă layerCount > 3) cu culorile proprii
        if (layerCount > 3 && extraExpandedD && extraExpandedD.length) {
          const extrasUsed = extraLayers.slice(0, Math.max(0, Math.min(2, layerCount-3)));
          extraExpandedD.forEach((d, idx) => {
            const meta = extrasUsed[idx] || {};
            if (d && meta.show !== false) {
              out += `<path d="${d}" fill="${meta.color || cBase}"/>`;
            }
          });
        }

        // MID
        if (layerCount >= 3 && showMid) {
          if (midExpanded && midExpandedD) {
            out += `<path d="${midExpandedD}" fill="${cMid}"/>`;
          } else {
            (paths||[]).forEach(d=>{
              out += `<path d="${d}" fill="${cMid}"/>`;
              out += `<path d="${d}" fill="none" stroke="${cMid}" stroke-width="${Math.max(1, Math.round(padMid||0))}" stroke-linejoin="${round ? "round":"miter"}" stroke-linecap="${round ? "round":"butt"}"/>`;
            });
          }
        }

        // TOP (la final)
        if (showTop) {
          paths.forEach(d => { out += `<path d="${d}" fill="${cTop}"/>`; });
        }
        out += `</svg>`;
        const blob = new Blob([out], { type: "image/svg+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = "text-3layers.svg";
        a.click();
        URL.revokeObjectURL(a.href);
      }
      function downloadSingleLayer(layerKey){
        if (!paths || !paths.length) return;
        const lineJoin = round ? "round" : "miter";
        const lineCap = round ? "round" : "butt";
        const midStroke = Math.max(1, Math.round(padMid  || 0));
        const baseStroke = Math.max(1, Math.round(padBase || 0));
        const topStroke  = Math.max(0, Math.round(padTop  || 0));
        const outlineMid = false;
        const outlineBase = false;
        let layerSVG = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${DESIGN_W} ${DESIGN_H}" width="${DESIGN_W}" height="${DESIGN_H}">`;
        if (layerKey === "top") {
          paths.forEach(d => {
            if (topStroke>0) layerSVG += `<path d="${d}" fill="none" stroke="${cTop}" stroke-width="${topStroke}" stroke-linejoin="${lineJoin}" stroke-linecap="${lineCap}"/>`;
            layerSVG += `<path d="${d}" fill="${cTop}"/>`;
          });
        } else if (layerKey === "mid") {
          if (midExpanded && midExpandedD) {
            layerSVG += `<path d="${midExpandedD}" fill="${cMid}"/>`;
          } else {
            (paths||[]).forEach(d=>{ if(!outlineMid) layerSVG+=`<path d="${d}" fill="${cMid}"/>`; layerSVG+=`<path d="${d}" fill="none" stroke="${cMid}" stroke-width="${midStroke}" stroke-linejoin="${lineJoin}" stroke-linecap="${lineCap}"/>`;});
          }
        } else if (layerKey === "base") {
          if (baseExpanded && baseExpandedD) {
            layerSVG += `<path d="${baseExpandedD}" fill="${cBase}"/>`;
          } else {
            (paths||[]).forEach(d=>{ if(!outlineBase) layerSVG+=`<path d="${d}" fill="${cBase}"/>`; layerSVG+=`<path d="${d}" fill="none" stroke="${cBase}" stroke-width="${baseStroke}" stroke-linejoin="${lineJoin}" stroke-linecap="${lineCap}"/>`;});
          }
        }
        layerSVG += `</svg>`;
        const blob = new Blob([layerSVG], { type: "image/svg+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = `text-3layers-${layerKey}.svg`;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      // UI
      // --- Sticker selection helpers (pune asta înainte de return-ul cu UI) ---
      const hasSelSticker =
        typeof selectedStickerIdx === "number" &&
        selectedStickerIdx >= 0 &&
        Array.isArray(stickers) &&
        stickers[selectedStickerIdx];

      const selSticker   = hasSelSticker ? stickers[selectedStickerIdx] : null;
      const selLayers    = {
        count: selSticker?.layerCount ?? 3,
        showTop: selSticker?.layers?.top?.show !== false,
        showMid: selSticker?.layers?.mid?.show !== false,
        showBase: selSticker?.layers?.base?.show !== false,
        padMid: selSticker?.layers?.mid?.pad ?? 16,
        padBase: selSticker?.layers?.base?.pad ?? 28,
        round: selSticker?.layers?.rounded ?? true
      };
      const setSelSticker = (fnOrPatch) => {
        setStickers(prev =>
          prev.map((it,i) =>
            i === selectedStickerIdx
              ? (typeof fnOrPatch === "function" ? fnOrPatch(it) : { ...it, ...fnOrPatch })
              : it
          )
        );
      };

      // panelul de layere pentru stickerul selectat – un ELEMENT gata de pus în lista de copii
      const stickerLayerPanel = hasSelSticker ? React.createElement(
        React.Fragment,
        { key: "sticker-layer-panel" },
        React.createElement("div", { className: "label", style:{marginTop:10} }, "Layere sticker"),
        React.createElement("div", { className:"controls-row" }, [
          React.createElement("div", { key:"sl-count" }, [
            React.createElement("div", { className:"label" }, "Număr layere"),
            React.createElement("input", {
              type:"number", min:1, max:5, value: String(selLayers.count),
              onChange: e => {
                const v = Math.max(1, Math.min(5, parseInt(e.target.value||"1",10)));
                setSelSticker(s => ({ ...s, layerCount: v }));
              }
            })
          ]),
          React.createElement("div", { key:"sl-round" }, [
            React.createElement("div", { className:"label" }, "Rotunjit"),
            React.createElement("label", { style:{display:"flex",gap:6,alignItems:"center"} },
              React.createElement("input", {
                type:"checkbox",
                checked: !!selLayers.round,
                onChange: e => setSelSticker(s => ({ ...s, layers: { ...(s.layers||{}), rounded: e.target.checked } }))
              }),
              "colțuri rotunjite"
            )
          ])
        ]),
        // grosimi (pad) pentru mijloc și bază (exemplu)
        React.createElement("div", { className:"controls-row" }, [
          React.createElement("div", { key:"sl-mid" }, [
            React.createElement("div", { className:"label" }, "Grosime (Mijloc)"),
            React.createElement("input", {
              type:"range", min:0, max:80, step:1, value: String(selLayers.padMid ?? 10),
              onChange: e => setSelSticker(s => ({ ...s, layers: { ...(s.layers||{}), mid: { ...(s.layers?.mid||{}), pad: +e.target.value } } }))
            })
          ]),
          React.createElement("div", { key:"sl-base" }, [
            React.createElement("div", { className:"label" }, "Grosime (Bază)"),
            React.createElement("input", {
              type:"range", min:1, max:200, step:1, value: String(selLayers.padBase ?? 20),
              onChange: e => setSelSticker(s => ({ ...s, layers: { ...(s.layers||{}), base: { ...(s.layers?.base||{}), pad: +e.target.value } } }))
            })
          ])
        ]),
        // vizibilități
        React.createElement("div", { className:"controls-row" }, [
          React.createElement("button", {
            key:"sl-showTop",
            className:"icon-btn",
            "aria-pressed": selLayers.showTop !== false,
            onClick: () => setSelSticker(s => ({ ...s, layers: { ...(s.layers||{}), top: { ...(s.layers?.top||{}), show: !(s.layers?.top?.show !== false) } } }))
          }, "Top"),
          React.createElement("button", {
            key:"sl-showMid",
            className:"icon-btn",
            "aria-pressed": selLayers.showMid !== false,
            onClick: () => setSelSticker(s => ({ ...s, layers: { ...(s.layers||{}), mid: { ...(s.layers?.mid||{}), show: !(s.layers?.mid?.show !== false) } } }))
          }, "Mid"),
          React.createElement("button", {
            key:"sl-showBase",
            className:"icon-btn",
            "aria-pressed": selLayers.showBase !== false,
            onClick: () => setSelSticker(s => ({ ...s, layers: { ...(s.layers||{}), base: { ...(s.layers?.base||{}), show: !(s.layers?.base?.show !== false) } } }))
          }, "Bază")
        ])
      ) : null;

      // === Helpers pt mișcare text (când nu e sticker selectat) ===
      const nudgeLines = React.useCallback((dx, dy) => {
        setLines(prev => ({
          line1: { ...(prev.line1||{}), x:(prev.line1?.x||0)+dx, y:(prev.line1?.y||0)+dy },
          line2: { ...(prev.line2||{}), x:(prev.line2?.x||0)+dx, y:(prev.line2?.y||0)+dy },
          line3: { ...(prev.line3||{}), x:(prev.line3?.x||0)+dx, y:(prev.line3?.y||0)+dy }
        }));
      }, [setLines]);

      // === Keyboard shortcuts ===
      const onKeyDown = React.useCallback((e) => {
        // nu intervenim când utilizatorul scrie în input-uri
        const tag = (document.activeElement?.tagName || "").toLowerCase();
        if (tag === "input" || tag === "textarea" || tag === "select" || document.activeElement?.isContentEditable) return;

        const step = e.shiftKey ? 10 : 1;
        const scaleSmall = e.shiftKey ? 0.15 : 0.05;  // pentru font și sticker
        const rotStep = e.shiftKey ? 15 : 5;

        const hasSel = (typeof selectedStickerIdx === "number" &&
                        selectedStickerIdx >= 0 &&
                        Array.isArray(stickers) &&
                        !!stickers[selectedStickerIdx]);

        // mișcare (săgeți)
        if (e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "ArrowUp" || e.key === "ArrowDown") {
          e.preventDefault();
          const dx = (e.key === "ArrowLeft" ? -step : e.key === "ArrowRight" ? step : 0);
          const dy = (e.key === "ArrowUp"   ? -step : e.key === "ArrowDown"  ? step : 0);
          if (hasSel) {
            setStickers(prev => prev.map((it,i)=> i===selectedStickerIdx ? {...it, x:(it.x||0)+dx, y:(it.y||0)+dy} : it));
          } else {
            nudgeLines(dx, dy);
          }
          return;
        }

        // scale: + / -
        if (e.key === "+" || e.key === "=" || e.key === "-" || e.key === "_") {
          e.preventDefault();
          if (hasSel) {
            setStickers(prev => prev.map((it,i)=>{
              if (i!==selectedStickerIdx) return it;
              const mul = (e.key === "+" || e.key === "=") ? (1+scaleSmall) : (1-scaleSmall);
              const next = Math.max(0.05, Math.min(50, (it.scale||1) * mul));
              return {...it, scale: next};
            }));
          } else {
            const delta = Math.max(1, Math.round((e.shiftKey ? 10 : 1)));
            setFontSizePx(v => {
              const d = (e.key === "+" || e.key === "=") ? +delta : -delta;
              return Math.max(8, Math.min(5000, v + d));
            });
          }
          return;
        }

        // rotire: R / Shift+R (doar pentru sticker)
        if ((e.key === "r" || e.key === "R") && hasSel) {
          e.preventDefault();
          setStickers(prev => prev.map((it,i)=> i===selectedStickerIdx
            ? {...it, rotation: Math.max(-180, Math.min(180, Math.round((it.rotation||0) + (e.shiftKey ? rotStep : rotStep))))}
            : it
          ));
          return;
        }

        // Delete / Backspace: șterge stickerul selectat
        if ((e.key === "Delete" || e.key === "Backspace") && hasSel) {
          e.preventDefault();
          setStickers(prev => prev.filter((_,i)=> i!==selectedStickerIdx));
          setSelectedStickerIdx(-1);
          return;
        }

        // Ctrl + D: duplicate sticker
        if ((e.ctrlKey || e.metaKey) && (e.key === "d" || e.key === "D") && hasSel) {
          e.preventDefault();
          setStickers(prev => {
            const src = prev[selectedStickerIdx];
            if (!src) return prev;
            const dup = {...src, x:(src.x||0)+20, y:(src.y||0)+20};
            const next = prev.slice(0, selectedStickerIdx+1).concat([dup], prev.slice(selectedStickerIdx+1));
            // selectăm duplicatul (următorul index)
            setSelectedStickerIdx(selectedStickerIdx+1);
            return next;
          });
          return;
        }

        // Esc: deselect
        if (e.key === "Escape" && hasSel) {
          e.preventDefault();
          setSelectedStickerIdx(-1);
          return;
        }

        // Zoom: Z (in) / X (out)
        if (e.key === "z" || e.key === "Z" || e.key === "x" || e.key === "X") {
          e.preventDefault();
          setZoom(z => {
            const mul = (e.key === "z" || e.key === "Z") ? 1.1 : 1/1.1;
            return Math.max(0.05, Math.min(2, z * mul));
          });
          return;
        }

        // Fit: F
        if (e.key === "f" || e.key === "F") {
          e.preventDefault();
          // reusează fitZoom deja definit
          fitZoom();
          return;
        }

        // Ctrl + [1..5] => set layer count (sticker sau global)
        if ((e.ctrlKey || e.metaKey) && ["1","2","3","4","5"].includes(e.key)) {
          e.preventDefault();
          const val = parseInt(e.key, 10);
          if (hasSel) {
            setStickers(prev => prev.map((it,i)=> i===selectedStickerIdx ? {...it, layerCount: val} : it));
          } else {
            setLayerCount(val);
          }
          pushHistory();
          return;
        }
      
        // Undo / Redo
        if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "z") {
          e.preventDefault();
          if (e.shiftKey) {
            redo();
          } else {
            undo();
          }
          return;
        }
      }, [
        selectedStickerIdx, stickers, setStickers,
        setLines, nudgeLines,
        setFontSizePx, setZoom, fitZoom,
        setLayerCount,
        undo, redo, pushHistory
      ]);

      // atașăm/detașăm listenerul
      React.useEffect(() => {
        window.addEventListener("keydown", onKeyDown);
        return () => window.removeEventListener("keydown", onKeyDown);
      }, [onKeyDown]);

      return React.createElement(
        React.Fragment,
        null,

        // Panou stânga: scroll vertical ca să rămână canvasul vizibil
        React.createElement(
          "div",
          {
            className:"card",
            style:{
              position:"sticky", top:16,
              maxHeight:"calc(100vh - 48px)",  // 24px margine sus + jos din .wrap
              overflowY:"auto",
              overscrollBehavior:"contain"
            }
          },

          React.createElement("div", { className:"label" }, "Font"),
          React.createElement(
            "select",
            { value: fontId, onChange: e=>setFontId(e.target.value) },
            ...(fonts.map(f => React.createElement("option", { key:(f.id ?? f.file), value:(f.id ?? f.file) }, f.label || f.id || f.file)))
          ),
          loadMsg ? React.createElement("div", { className:"hint" }, loadMsg) : null,

          React.createElement("div", { className:"label" }, "Text (rând 1)"),
          React.createElement("input", { type:"text", value:text, onInput:e=>setText(e.target.value) }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Text 2 (opțional)"),
          React.createElement("input", { type:"text", value:text2, onInput:e=>setText2(e.target.value) }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Text 3 (opțional)"),
          React.createElement("input", { type:"text", value:text3, onInput:e=>setText3(e.target.value) }),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Stickere"),
          React.createElement("div", { style:{display:"flex", gap:8, flexWrap:"wrap"} },
            stickersLib.map(st =>
              React.createElement("button", {
                key: st.id,
                onClick: () => addStickerToCanvas(st),
                title: st.label,
                style:{
                  width:48,height:48,border:"1px solid #d1d5db",borderRadius:8,background:"#fff",
                  display:"flex",alignItems:"center",justifyContent:"center",cursor:"pointer"
                }
              },
                React.createElement("svg", { viewBox:"0 0 24 24", width:24, height:24 },
                  React.createElement("path", { d: st.d, fill:"#111827" })
                )
              )
            )
          ),

          (selectedStickerIdx >= 0 && stickers[selectedStickerIdx])
            ? React.createElement(
                React.Fragment,
                null,
                React.createElement("div", { className:"label", style:{marginTop:10} }, "Sticker selectat"),
                React.createElement("div", { className:"controls-row" }, [
                  React.createElement("div", null, [
                    React.createElement("div", { className:"label" }, "Culoare"),
                    React.createElement("input", {
                      type:"color",
                      value: stickers[selectedStickerIdx].color,
                      onInput: e => setStickers(prev => prev.map((it, i) =>
                        i === selectedStickerIdx ? { ...it, color: e.target.value } : it
                      ))
                    })
                  ]),
                  React.createElement("div", null, [
                    React.createElement("div", { className:"label" }, "Mărime"),
                    React.createElement(SizeDial, {
                      key:"dial-sticker",
                      title:"Mărime sticker",
                      value: stickers[selectedStickerIdx]?.scale ?? 1,
                      onChange: v => setStickers(prev =>
                        prev.map((it,i)=> i===selectedStickerIdx ? {...it, scale: parseFloat(v)} : it)
                      ),
                      min: 0.1, max: 50, step: 0.1, bigStep: 1, size: 56
                    })
                  ])
                ]),
                React.createElement("div", { className:"controls-row" }, [
                  React.createElement("div", null, [
                    React.createElement("div", { className:"label" }, "Rotire"),
                    React.createElement("input", {
                      type:"range", min:-180, max:180, step:1,
                      value: stickers[selectedStickerIdx].rotation,
                      onChange: e => setStickers(prev => prev.map((it, i) =>
                        i === selectedStickerIdx ? { ...it, rotation: parseInt(e.target.value,10) } : it
                      ))
                    })
                  ]),
                  React.createElement("div", null, [
                    React.createElement("div", { className:"label" }, "Șterge"),
                    React.createElement("button", {
                      className:"btn",
                      onClick: () => {
                        setStickers(prev => prev.filter((_,i)=> i!==selectedStickerIdx));
                        setSelectedStickerIdx(-1);
                      }
                    }, "Remove")
                  ])
                ]),
                stickerLayerPanel
              )
            : null,

          React.createElement("div", { className:"controls-row-3 control-compact", style:{marginTop:10} }, [
            React.createElement("div", { className:"control" }, [
              React.createElement("div", { className:"label" }, "Spațiere rânduri"),
              React.createElement("input", {
                type:"number", step:"0.05", min:"0.4", max:"3",
                value: toValueStr(lineSpacing),
                onChange: e => {
                  const v = toNum(e.target.value, 0.95);
                  setLineSpacing(v > 0 ? Math.min(3, Math.max(0.4, v)) : 0.95);
                }
              })
            ]),
            React.createElement("div", { className:"control" }, [
              React.createElement("div", { className:"label" }, "Font size"),
              React.createElement("input", {
                type:"number", min:10, max:5000,
                value: toValueStr(fontSizePx),
                onChange: e => {
                  setFontSizePx(toNum(e.target.value, 140));
                  pushHistory();
                }
              }),
              React.createElement("div",{style:{marginTop:8}},
                React.createElement(SizeDial, {
                  key:"dial-font",
                  title:"Font size",
                  value: fontSizePx,
                  onChange: v => setFontSizePx(Math.round(Math.max(8, Math.min(5000, v)))),
                  min: 8, max: 5000, step: 1, bigStep: 10, size: 56
                })
              )
            ]),
            React.createElement("div", { className:"control" }, [
              React.createElement("div", { className:"label" }, "Spațiere litere"),
              React.createElement("input", {
                type:"number", step:"0.5", min:"-10", max:"100",
                value: toValueStr(letterSpacing),
                onChange: e => setLetterSpacing(clamp(toNum(e.target.value, 0), -10, 100))
              })
            ])
          ]),
 
          // Mutare se face direct în canvas (drag) sau cu săgeți (±1px / Shift ±10px)
          React.createElement("div", { className:"hint" }, "Mută textul direct în canvas (drag) • Săgeți: ±1px, cu Shift: ±10px"),
          React.createElement("div", { className:"hint" },
            "Shortcuturi: Săgeți (mișcare) • Shift = ×10 • +/- (scală) • R/Shift+R (rotire sticker) • Delete (șterge) • Ctrl+D (duplică) • Z/X (zoom) • F (Fit) • Ctrl+1..5 (layere)"
          ),

          /* (mutat în overlay-ul din canvas) */

          // === Transform (tip Illustrator – referință: centru) ===
          React.createElement("div", { className:"label", style:{marginTop:10} }, "Transform"),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Unități"),
              React.createElement("select", {
                value: unit,
                onChange: e => setUnit(e.target.value)
              }, [
                React.createElement("option", { key:"px", value:"px" }, "px"),
                React.createElement("option", { key:"mm", value:"mm" }, "mm"),
                React.createElement("option", { key:"cm", value:"cm" }, "cm"),
                React.createElement("option", { key:"in", value:"in" }, "in")
              ])
            ]),
            React.createElement("div", null)
          ]),
          React.createElement("div", { className:"transform-grid" }, [
            React.createElement("div", { className:"cell", key:"x" }, [
              React.createElement("div", { className:"label" }, "X"),
              React.createElement("input", {
                type:"number",
                step: stepByUnit[unit],
                value: dispX,
                onChange: onXChangeU
              })
            ]),
            React.createElement("div", { className:"cell", key:"y" }, [
              React.createElement("div", { className:"label" }, "Y"),
              React.createElement("input", {
                type:"number",
                step: stepByUnit[unit],
                value: dispY,
                onChange: onYChangeU
              })
            ]),
            React.createElement("div", { className:"cell", key:"w" }, [
              React.createElement("div", { className:"label" }, "W"),
              React.createElement("input", {
                type:"number",
                min: stepByUnit[unit],
                step: stepByUnit[unit],
                value: dispW,
                onChange: onWChangeU
              })
            ]),
            React.createElement("div", { className:"cell", key:"h" }, [
              React.createElement("div", { className:"label" }, "H"),
              React.createElement("input", {
                type:"number",
                min: stepByUnit[unit],
                step: stepByUnit[unit],
                value: dispH,
                onChange: onHChangeU
              })
            ])
          ]),
          React.createElement("div", { className:"hint" }, `Scalare uniformă (păstrează proporțiile) • Unitate curentă: ${unit}`),

          // === Select număr de layere (1–5) ===
          React.createElement("div", { className:"label", style:{marginTop:10} }, "Layere (1–5)"),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", { key:"lc-input" }, [
              React.createElement("input", {
                type:"number", min:1, max:5, step:1,
                value: String(layerCount),
                onChange: e => {
                  const v = parseInt(e.target.value || "3", 10);
                  const clamped = Math.min(5, Math.max(1, isNaN(v) ? 3 : v));
                  setLayerCount(clamped);
                  pushHistory();
                }
              })
            ]),
            React.createElement("div", { key:"lc-buttons", style:{display:"flex", gap:6, alignItems:"center", justifyContent:"flex-end"} },
              [1,2,3,4,5].map(n =>
                React.createElement("button", {
                  key:`btn-${n}`,
                  type:"button",
                  onClick: ()=>setLayerCount(n),
                  className:"icon-btn",
                  "aria-pressed": layerCount===n,
                  title: `${n} ${n===1?'layer':'layere'}`
                }, String(n))
              )
            )
          ]),
          React.createElement("div", { className:"hint" },
            "1: doar Top • 2: Top + Bază • 3: Top + Mijloc + Bază • 4/5: layere intermediare între Mijloc și Bază"
          ),

          React.createElement("div", { className:"label", style:{marginTop:10} }, "Layere"),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Layer 1 (Top)"),
              React.createElement("div", { className:"layer-row" }, [
                React.createElement("input", { type:"color", value:cTop, onInput:e=>setCTop(e.target.value) }),
                React.createElement("button", { className:"eye-btn", "aria-pressed": showTop, onClick: () => setShowTop(!showTop) }, EyeIcon(showTop))
              ]),
             React.createElement("div", { className:"label", style:{marginTop:6} }, "Grosime (Top)"),
             React.createElement("input", {
               type:"range", min:0, max:160,
               value: toValueStr(padTop),
               onChange: e => setPadTop(toNum(e.target.value, 0))
             })
            ]),
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Layer 2 (Mijloc)"),
              React.createElement("div", { className:"layer-row" }, [
                React.createElement("input", { type:"color", value:cMid, onInput:e=>setCMid(e.target.value) }),
                React.createElement("button", { className:"eye-btn", "aria-pressed": showMid, onClick: () => setShowMid(!showMid) }, EyeIcon(showMid))
              ]),
              React.createElement("div", { className:"label", style:{marginTop:6} }, "Grosime (Mijloc)"),
              React.createElement("input", {
                type:"range", min:0, max:50, step:1,
                value: padMid,
                onChange: e => {
                  setPadMid(+e.target.value);
                  pushHistory();
                }
              }),
              React.createElement("div", { style:{ display:"flex", gap:6, marginTop:4 } }, [
                React.createElement("button", {
                  onClick: () => (window.applyExpandMid ? window.applyExpandMid() : console.log("applyExpandMid placeholder")),
                  style: { padding: "2px 6px", fontSize: 12, cursor: "pointer" }
                }, "Set"),
                React.createElement("button", {
                  onClick: () => (window.resetExpandMid ? window.resetExpandMid() : console.log("resetExpandMid placeholder")),
                  style: { padding: "2px 6px", fontSize: 12, cursor: "pointer", background:"#eee", border:"1px solid #d1d5db", borderRadius:6 }
                }, "Reset")
              ])
            ])
          ]),
          React.createElement("div", { className:"controls-row" }, [
            React.createElement("div", null, [
              React.createElement("div", { className:"label" }, "Layer 3 (Bază)"),
              React.createElement("div", { className:"layer-row" }, [
                React.createElement("input", { type:"color", value:cBase, onInput:e=>setCBase(e.target.value) }),
                React.createElement("button", { className:"eye-btn", "aria-pressed": showBase, onClick: () => setShowBase(!showBase) }, EyeIcon(showBase))
              ]),
              React.createElement("div", { className:"label", style:{marginTop:6} }, "Grosime (Bază)"),
              React.createElement("div", { className:"controls-row", style:{ gap:8, alignItems:"center" } }, [
                React.createElement("input", {
                  type:"range", min:1, max:200,
                  value: toValueStr(padBase),
                  onChange: e => setPadBase(toNum(e.target.value, 28))
                }),
                React.createElement("button", {
                  onClick: () => (window.applyExpandBase ? window.applyExpandBase() : console.log("applyExpandBase placeholder")),
                  style: { marginTop: 4, padding: "2px 6px", fontSize: 12, cursor: "pointer" }
                }, "Set"),
                React.createElement("button", {
                  onClick: () => (window.resetExpandBase ? window.resetExpandBase() : console.log("resetExpandBase placeholder")),
                  style: { padding: "2px 6px", fontSize: 12, cursor: "pointer", background:"#eee", border:"1px solid #d1d5db", borderRadius:6 }
                }, "Reset")
              ])
            ]),
            React.createElement("div", null)
          ]),

          // --- Layere Intermediare (4/5) ---
          (layerCount > 3) ? React.createElement(
            React.Fragment,
            { key:"extraLayersUI" },
            extraLayers.slice(0, Math.max(0, Math.min(2, layerCount-3))).map((ex, idx) => (
              React.createElement("div", { className:"controls-row", key:`ui-extra-${ex.id}` }, [
                React.createElement("div", { key:`extra-${ex.id}-left` }, [
                  React.createElement("div", { className:"label" }, `Layer ${ex.id} (Intermediar ${idx+1})`),
                  React.createElement("div", { className:"layer-row" }, [
                    React.createElement("input", {
                      type:"color",
                      value: ex.color,
                      onInput: e => setExtraLayers(prev => prev.map((it,i)=> i===idx ? {...it, color: e.target.value} : it))
                    }),
                    React.createElement("button", {
                      className:"eye-btn",
                      "aria-pressed": ex.show !== false,
                      onClick: () => setExtraLayers(prev => prev.map((it,i)=> i===idx ? {...it, show: !(it.show !== false)} : it))
                    }, EyeIcon(ex.show !== false))
                  ]),
                  React.createElement("div", { className:"label", style:{marginTop:6} }, "Grosime (Intermediar)"),
                  React.createElement("div", { className:"controls-row", style:{ gap:8, alignItems:"center" } }, [
                    React.createElement("input", {
                      type:"range", min:1, max:200,
                      value: String(ex.pad),
                      onChange: e => {
                        const v = Math.max(1, Math.min(200, parseInt(e.target.value||ex.pad,10) || ex.pad));
                        setExtraLayers(prev => prev.map((it,i)=> i===idx ? {...it, pad: v} : it));
                      }
                    }),
                    React.createElement("button", {
                      onClick: () => setExtraLayers(prev => prev.map((it,i)=> i===idx ? {...it, expanded: true} : it)),
                      style: { marginTop: 4, padding: "2px 6px", fontSize: 12, cursor: "pointer" }
                    }, "Set")
                  ])
                ]),
                React.createElement("div", { key:`extra-${ex.id}-right` })
              ])
            ))
          ) : null,

          /* blocul de vizibilitate separat a fost înlocuit de iconițe lângă culori */

          React.createElement("label", { style:{display:"flex", gap:8, alignItems:"center", marginTop:8} },
            React.createElement("input", { type:"checkbox", checked:round, onChange:e=>setRound(e.target.checked) }),
            React.createElement("span", null, "Rotunjit")
          ),

          React.createElement("div", { style:{marginTop:12, display:"grid", gap:"8px"} },
            // <-- Butonul nou de reset total
            React.createElement("button", {
              key:"btn-reset-total",
              className:"btn",
              onClick: resetDesign,
              style:{ background:"#ef4444", borderColor:"#ef4444" }
            }, "Resetare totală"),
            React.createElement("div", { key:"undo-redo-row", className:"controls-row", style:{gap:6} }, [
              React.createElement("button", { onClick: undo, className:"btn" }, "Undo"),
              React.createElement("button", { onClick: redo, className:"btn" }, "Redo")
            ]),
            React.createElement("button", {
              key:"btn-export-all",
              className:"btn",
              onClick:downloadSVG,
              disabled: !paths || !paths.length
            }, "Descarcă SVG (toate layerele)"),
            React.createElement("div", { key:"row-export-1", className:"controls-row" },
              React.createElement("button", { className:"btn", onClick:()=>downloadSingleLayer("top"), disabled: !paths || !paths.length }, "Descarcă Layer Top"),
              React.createElement("button", { className:"btn", onClick:()=>downloadSingleLayer("mid"), disabled: !paths || !paths.length }, "Descarcă Layer Mid")
            ),
            React.createElement("div", { key:"row-export-2", className:"controls-row" },
              React.createElement("button", { className:"btn", onClick:()=>downloadSingleLayer("base"), disabled: !paths || !paths.length }, "Descarcă Layer Bază")
            )
          ),

          React.createElement("div", { className:"hint" }, "Fonturile sunt citite din /assets/fonts/fonts.json (chei: id, label, file).")
        ),

        // CARD PREVIEW
        React.createElement(
          "div",
          { className:"card" },
          React.createElement(
            "div",
            { className:"grid" },
            [
              React.createElement(Preview, {
                svgRef,
                paths,
                textBBox,
                colors: previewColors,
                padMid,
                padBase,
                padTop,
                showTop,
                showMid,
                showBase,
                rounded: round,
                fontSizePx,
                setFontSizePx,
                lineData,
                lineOffsets,
                setLines,
                zoom,
                midExpanded,
                midExpandedD,
                baseExpanded,
                baseExpandedD,
                extraExpandedD,
                layerCount,
                extraMeta: extraLayers.slice(0, Math.max(0, Math.min(2, layerCount-3))),
                stickers: stickers,
                onStickerDrag: (idx, nx, ny) => {
                  setStickers(prev => prev.map((it, i) => i===idx ? {...it, x:nx, y:ny} : it));
                },
                onStickerSelect: (idx) => setSelectedStickerIdx(idx),
                setStickers: setStickers,
                stickerDefs: stickersLib,
                selectedStickerIdx
              }),
              React.createElement("div", { className:"zoom-overlay" }, [
                React.createElement("input", {
                  key:"z1", type:"range", min:0.05, max:2, step:0.01,
                  value: zoom,
                  onChange: e => setZoom(clamp(parseFloat(e.target.value)||1, 0.05, 2))
                }),
                React.createElement("button", { key:"z2", className:"btn", type:"button", onClick: fitZoom }, "Fit"),
                React.createElement("button", { key:"z3", className:"btn", type:"button", onClick: resetZoom }, "100%")
              ])
            ]
          )
        )
      );
    }

    ReactDOM.createRoot(document.getElementById("app")).render(React.createElement(App));
    console.log("%cindex.html simplu – gata", "color:#16a34a");
  </script>
  <script>
  window.LCS.setAdapters({ getSnapshot: window.getSnapshot, applySnapshot: window.applySnapshot });
  </script>
  <!-- 1) HistoryManager (fără dependențe) -->
  <script>
  (function () {
    const now = () => Date.now();
    const deepClone = (obj) => {
      if (typeof structuredClone === 'function') return structuredClone(obj);
      return JSON.parse(JSON.stringify(obj));
    };

    class HistoryManager {
      constructor({ limit = 200, minIntervalMs = 80, coalesceWindowMs = 300 } = {}) {
        this.limit = limit;
        this.minIntervalMs = minIntervalMs;
        this.coalesceWindowMs = coalesceWindowMs;
        this.stack = [];
        this.index = -1;
        this._lastPushTs = 0;
        this._lastReason = '';
        this._isApplying = false;
        this._adapters = {
          getSnapshot: () => ({}),
          applySnapshot: (_snap) => {},
          onDidApply: null,
        };
      }
      setAdapters({ getSnapshot, applySnapshot, onDidApply } = {}) {
        if (typeof getSnapshot === 'function') this._adapters.getSnapshot = getSnapshot;
        if (typeof applySnapshot === 'function') this._adapters.applySnapshot = applySnapshot;
        if (typeof onDidApply === 'function') this._adapters.onDidApply = onDidApply;
      }
      _current() { return this.index >= 0 ? this.stack[this.index] : null; }
      canUndo() { return this.index > 0; }
      canRedo() { return this.index >= 0 && this.index < this.stack.length - 1; }
      _shouldCoalesce(reason) {
        const t = now();
        return !!(reason && reason === this._lastReason && (t - this._lastPushTs) <= this.coalesceWindowMs);
      }
      push(reason = '') {
        const t = now();
        if (t - this._lastPushTs < this.minIntervalMs) return; // throttle anti-spam
        const snap = deepClone(this._adapters.getSnapshot() || {});
        // Dacă suntem în mijlocul stivei (după undo), tăiem viitorul
        if (this.index < this.stack.length - 1) {
          this.stack = this.stack.slice(0, this.index + 1);
        }
        if (this._shouldCoalesce(reason) && this.stack.length) {
          this.stack[this.stack.length - 1] = snap;
        } else {
          this.stack.push(snap);
          if (this.stack.length > this.limit) {
            this.stack.shift();
          } else {
            this.index++;
          }
        }
        this._lastPushTs = t;
        this._lastReason = reason;
      }
      undo() {
        if (!this.canUndo()) return;
        this.index--;
        this._applyCurrent('undo');
      }
      redo() {
        if (!this.canRedo()) return;
        this.index++;
        this._applyCurrent('redo');
      }
      peek() { return this._current(); }
      _applyCurrent(kind) {
        const snap = this._current();
        if (!snap) return;
        let applied = null;
        try {
          this._isApplying = true;
          applied = deepClone(snap);
          this._adapters.applySnapshot(applied);
        } finally {
          this._isApplying = false;
        }
        if (this._adapters.onDidApply) this._adapters.onDidApply(kind, applied);
        window.dispatchEvent(new CustomEvent('lcs:state-applied', { detail: { kind, snapshot: applied } }));
      }
    }

    window.__LCS_HistoryManager__ = HistoryManager;
  })();
  </script>

  <!-- 2) Adaptor + Defaults (evită TDZ și erori „Cannot access 'X' before initialization”) -->
  <script>
  (function () {
    // DEFINIM starea implicită ÎNAINTE de orice folosire
    const defaultState = {
      version: 1,
      text: '',
      layers: [],
      stickers: [],
      colors: { palette: ['#000000', '#ffffff'], currentFill: '#000000', currentStroke: '#000000' },
      strokeWidth: 1,
      zoom: 1,      // <- definit aici, nu va exista TDZ
      unit: 'mm',   // <- la fel
      guides: [],
      selection: null,
      canvas: { width: 800, height: 480 },
      meta: { updatedAt: Date.now() }
    };

    // Stare „aplicație” sigură (poți înlocui ulterior cu state-ul tău real)
    var appState = (typeof structuredClone === 'function')
      ? structuredClone(defaultState)
      : JSON.parse(JSON.stringify(defaultState));

    // Render extern (îl definim mai jos, după ce montăm React); aici doar îl referim
    var renderApp = function noop() {};

    // Utils
    const deepClone = (obj) => (typeof structuredClone === 'function') ? structuredClone(obj) : JSON.parse(JSON.stringify(obj));
    const assignState = (src) => { Object.assign(appState, src); appState.meta.updatedAt = Date.now(); };

    // Inițializăm istoricul
    const HistoryManager = window.__LCS_HistoryManager__;
    const history = new HistoryManager({ limit: 250, minIntervalMs: 60, coalesceWindowMs: 280 });

    history.setAdapters({
      getSnapshot: () => deepClone(appState),
      applySnapshot: (snap) => {
        // normalizează înainte de a aplica
        if (window.__LCS_NORMALIZE__) {
          snap = window.__LCS_NORMALIZE__.normalizeSnapshot(snap);
        }
        assignState(snap);
        renderApp(appState);
      },
      onDidApply: (kind, snap) => {
        // Pentru siguranță, emitem event cu snap normalizat
        if (window.__LCS_NORMALIZE__) {
          snap = window.__LCS_NORMALIZE__.normalizeSnapshot(snap);
        }
        window.dispatchEvent(new CustomEvent('lcs:state-applied', { detail: { kind, snapshot: snap } }));
      }
    });

    // API global prietenos
    let _lastReasonTs = 0, _lastReason = '';
    function LCS_coalescedPush(reason = '', windowMs = 220) {
      const t = Date.now();
      if (!(reason && reason === _lastReason && (t - _lastReasonTs) <= windowMs)) {
        history.push(reason);
        _lastReason = reason;
      }
      _lastReasonTs = t;
    }

    window.LCS = {
      history,
      push: (r) => history.push(r),
      undo: () => history.undo(),
      redo: () => history.redo(),
      canUndo: () => history.canUndo(),
      canRedo: () => history.canRedo(),
      state: () => deepClone(history.peek() || appState),
      setAdapters: (adapters) => history.setAdapters(adapters),
      defaults: deepClone(defaultState),
      coalescedPush: LCS_coalescedPush
    };

    // Shortcut-uri tastatură (Ctrl+Z, Ctrl+Shift+Z, Ctrl+Y)
    if (!window.__LCS_KEYS_BOUND__) {
      window.__LCS_KEYS_BOUND__ = true;

      const isEditableTarget = (el) => {
        if (!el) return false;
        const tag = (el.tagName || '').toLowerCase();
        if (['input', 'textarea', 'select'].includes(tag)) return true;
        return !!el.isContentEditable;
      };

      window.addEventListener('keydown', (e) => {
        if (!e.ctrlKey && !e.metaKey) return;
        if (isEditableTarget(e.target)) return; // nu furăm Ctrl+Z în inputuri
        const key = (e.key || '').toLowerCase();
        const isShift = !!e.shiftKey;

        if (key === 'z' && !isShift) {
          if (history.canUndo()) { e.preventDefault(); history.undo(); }
          return;
        }
        if ((key === 'z' && isShift) || key === 'y') {
          if (history.canRedo()) { e.preventDefault(); history.redo(); }
          return;
        }
      }, { passive: false });
    }

    // Push inițial
    history.push('init');

    // Expunem global appState & render setter pentru demo
    window.__LCS_INTERNAL__ = {
      get appState() { return appState; },
      setRender(fn) { renderApp = typeof fn === 'function' ? fn : renderApp; }
    };
  })();
  </script>
  <script>
  (function () {
    // Așteaptă până când Managerul real setează window.LCS (non-stub)
    function ready(cb) {
      if (window.LCS && !window.LCS.__isStub__) return cb();
      const t = setInterval(() => {
        if (window.LCS && !window.LCS.__isStub__) { clearInterval(t); cb(); }
      }, 15);
    }

    ready(function () {
      // 1) Drenăm coada din stub (dacă a existat)
      if (window.__LCS_STUB__ && window.__LCS_STUB__.__q__) {
        try {
          const q = window.__LCS_STUB__.__q__;
          q.forEach(([op, args]) => { if (typeof window.LCS[op] === 'function') window.LCS[op](...args); });
        } catch (_) {}
      } else if (window.LCS && window.LCS.__isStub__ && window.LCS.__q__) {
        try {
          const q = window.LCS.__q__;
          // dacă încă e stub în acest moment, nu drena
          // (dar în mod normal aici deja e realul)
          q.forEach(([op, args]) => { if (typeof window.LCS[op] === 'function') window.LCS[op](...args); });
        } catch (_) {}
      }

      // 2) Expune global undo/redo ca să funcționeze onClick={undo} / onClick={redo}
      window.undo = function () { try { if (window.LCS?.canUndo()) window.LCS.undo(); } catch (_) {} };
      window.redo = function () { try { if (window.LCS?.canRedo()) window.LCS.redo(); } catch (_) {} };

      // 3) Shortcut-uri tastatură (o singură dată)
      if (!window.__LCS_KEYS_BOUND__) {
        window.__LCS_KEYS_BOUND__ = true;
        const isEditable = (el) => {
          if (!el) return false;
          const tag = (el.tagName || '').toLowerCase();
          if (['input','textarea','select'].includes(tag)) return true;
          return !!el.isContentEditable;
        };
        window.addEventListener('keydown', (e) => {
          if (!e.ctrlKey && !e.metaKey) return;
          if (isEditable(e.target)) return;
          const k = (e.key || '').toLowerCase();
          const sh = !!e.shiftKey;
          if (k === 'z' && !sh) {
            if (window.LCS?.canUndo()) { e.preventDefault(); window.LCS.undo(); }
            return;
          }
          if ((k === 'z' && sh) || k === 'y') {
            if (window.LCS?.canRedo()) { e.preventDefault(); window.LCS.redo(); }
            return;
          }
        }, { passive:false });
      }
    });
  })();
  </script>
  <script>
  (function () {
    // așteaptă până când LCS real e încărcat (non-stub)
    function whenReady(cb){
      if (window.LCS && !window.LCS.__isStub__) return cb();
      const t = setInterval(function(){
        if (window.LCS && !window.LCS.__isStub__) { clearInterval(t); cb(); }
      }, 15);
    }
    whenReady(function(){
      // 1) leagă funcțiile globale la LCS
      window.pushHistory = function(reason){ try{ window.LCS.push(reason||''); }catch(e){} };
      // coalescing simplu: cheamă LCS.coalescedPush dacă există, altfel push
      var _lastTs = 0, _lastR = '';
      window.pushHistoryCoalesced = function(reason, windowMs){
        reason = reason||''; windowMs = Number(windowMs)||250;
        if (window.LCS && typeof window.LCS.coalescedPush === 'function') {
          return window.LCS.coalescedPush(reason, windowMs);
        }
        var t = Date.now();
        if (!(reason && reason===_lastR && (t-_lastTs)<=windowMs)) window.LCS.push(reason);
        _lastR = reason; _lastTs = t;
      };
      window.undo = function(){ try{ if (window.LCS.canUndo()) window.LCS.undo(); }catch(e){} };
      window.redo = function(){ try{ if (window.LCS.canRedo()) window.LCS.redo(); }catch(e){} };

      // 2) shortcut-uri (o singură dată)
      if (!window.__LCS_KEYS_BOUND__){
        window.__LCS_KEYS_BOUND__ = true;
        var isEditable = function(el){
          if (!el) return false;
          var tag = (el.tagName||'').toLowerCase();
          if (['input','textarea','select'].includes(tag)) return true;
          return !!el.isContentEditable;
        };
        window.addEventListener('keydown', function(e){
          if (!e.ctrlKey && !e.metaKey) return;
          if (isEditable(e.target)) return;
          var k = (e.key||'').toLowerCase();
          var sh = !!e.shiftKey;
          if (k==='z' && !sh){ if (window.LCS.canUndo()){ e.preventDefault(); window.LCS.undo(); } return; }
          if ((k==='z' && sh) || k==='y'){ if (window.LCS.canRedo()){ e.preventDefault(); window.LCS.redo(); } return; }
        }, {passive:false});
      }
    });
  })();
  </script>
  <script>
  (function () {
    function whenReady(cb){
      if (window.LCS && !window.LCS.__isStub__) return cb();
      const t = setInterval(function(){
        if (window.LCS && !window.LCS.__isStub__) { clearInterval(t); cb(); }
      }, 15);
    }
    whenReady(function(){
      // push/undo/redo deja legate?
      window.pushHistory = function(reason){ try{ window.LCS.push(reason||''); }catch(e){} };
      var _lastTs = 0, _lastR = '';
      window.pushHistoryCoalesced = function(reason, windowMs){
        reason = reason||''; windowMs = Number(windowMs)||250;
        if (typeof window.LCS.coalescedPush === 'function') return window.LCS.coalescedPush(reason, windowMs);
        var t = Date.now();
        if (!(reason && reason===_lastR && (t-_lastTs)<=windowMs)) window.LCS.push(reason);
        _lastR = reason; _lastTs = t;
      };
      window.undo = function(){ try{ if (window.LCS.canUndo()) window.LCS.undo(); }catch(e){} };
      window.redo = function(){ try{ if (window.LCS.canRedo()) window.LCS.redo(); }catch(e){} };

      // resetDesign: revine la defaults + impinge snapshot in istoric
      window.resetDesign = function(){
        try {
          // preferă snapshot-ul real capturat la boot; dacă nu există, cade pe LCS.defaults
          var base = window.__LCS_BOOT_SNAPSHOT__ || (window.LCS && window.LCS.defaults) || null;
          if (!base) {
            window.dispatchEvent(new CustomEvent('lcs:reset-requested'));
            return;
          }

          // clona + opțional normalizează (dacă ai utilitarul din patch-urile anterioare)
          var raw = (typeof structuredClone==='function') ? structuredClone(base) : JSON.parse(JSON.stringify(base));
          var snap = (window.__LCS_NORMALIZE__ && typeof window.__LCS_NORMALIZE__.normalizeSnapshot === 'function')
            ? window.__LCS_NORMALIZE__.normalizeSnapshot(raw)
            : raw;

          // aplică snapshot-ul prin adaptor (asigură re-render)
          if (typeof window.applySnapshot === 'function') {
            window.applySnapshot(snap);
          } else if (window.__LCS_INTERNAL__ && window.__LCS_INTERNAL__.appState) {
            Object.assign(window.__LCS_INTERNAL__.appState, snap);
            window.dispatchEvent(new CustomEvent('lcs:state-applied', { detail:{ kind:'reset', snapshot:snap } }));
          } else if (window.appState) {
            Object.assign(window.appState, snap);
            window.dispatchEvent(new CustomEvent('lcs:state-applied', { detail:{ kind:'reset', snapshot:snap } }));
          } else {
            window.dispatchEvent(new CustomEvent('lcs:reset-requested'));
          }

          // resetează istoria la snapshot-ul curent
          if (window.LCS && window.LCS.history) {
            var keep = (typeof structuredClone==='function') ? structuredClone(snap) : JSON.parse(JSON.stringify(snap));
            window.LCS.history.stack = [keep];
            window.LCS.history.index = 0;
          }

          // marchează reset în istoric (opțional; nu afectează snapshot-ul păstrat)
          if (window.LCS && typeof window.LCS.push === 'function') window.LCS.push('reset');

          console.info('[resetDesign] done');
        } catch(e) {
          console.error('[resetDesign] error:', e);
        }
      };

      // Shortcut-uri (o singură dată)
      if (!window.__LCS_KEYS_BOUND__){
        window.__LCS_KEYS_BOUND__ = true;
        var isEditable = function(el){
          if (!el) return false;
          var tag = (el.tagName||'').toLowerCase();
          if (['input','textarea','select'].includes(tag)) return true;
          return !!el.isContentEditable;
        };
        window.addEventListener('keydown', function(e){
          if (!e.ctrlKey && !e.metaKey) return;
          if (isEditable(e.target)) return;
          var k = (e.key||'').toLowerCase();
          var sh = !!e.shiftKey;
          if (k==='z' && !sh){ if (window.LCS.canUndo()){ e.preventDefault(); window.LCS.undo(); } return; }
          if ((k==='z' && sh) || k==='y'){ if (window.LCS.canRedo()){ e.preventDefault(); window.LCS.redo(); } return; }
        }, {passive:false});
      }
    });
  })();
  </script>
  <!-- LCS Snapshot Normalizer + key helper -->
  <script>
  (function () {
    // Generează un ID stabil-ish pentru key în liste
    function ensureKey(idx, item) {
      if (item && (item.id || item.key)) return item.id || item.key;
      return 'k_' + idx;
    }
    window.ensureKey = ensureKey;

    // Completează câmpuri lipsă pe obiecte cunoscute (text lines/layers/stickers etc.)
    function fillKnownDefaults(obj) {
      if (!obj || typeof obj !== 'object') return obj;

      // 1) textLines: [{ line1, line2, font, size }]
      if (!Array.isArray(obj.textLines)) obj.textLines = [];
      obj.textLines = obj.textLines.filter(Boolean).map(function (t) {
        t = t && typeof t === 'object' ? t : {};
        if (typeof t.line1 !== 'string') t.line1 = '';
        if (typeof t.line2 !== 'string') t.line2 = '';
        if (typeof t.font !== 'string')  t.font = 'Inter';
        if (typeof t.size !== 'number')  t.size = 24;
        if (!('align' in t))             t.align = 'center';
        return t;
      });

      // 2) layers: stabilizează câmpuri de bază
      if (!Array.isArray(obj.layers)) obj.layers = [];
      obj.layers = obj.layers.filter(Boolean).map(function (l, i) {
        l = l && typeof l === 'object' ? l : {};
        if (!('id' in l)) l.id = 'L' + (i + 1);
        if (!('name' in l)) l.name = 'Layer ' + (i + 1);
        if (!('visible' in l)) l.visible = true;
        if (!('order' in l)) l.order = i;
        if (!('stroke' in l)) l.stroke = '#000000';
        if (!('fill' in l)) l.fill = '#ffffff';
        if (!('strokeWidth' in l)) l.strokeWidth = 1;
        return l;
      });

      // 3) stickers: normalizează obiectele
      if (!Array.isArray(obj.stickers)) obj.stickers = [];
      obj.stickers = obj.stickers.filter(Boolean).map(function (s, i) {
        s = s && typeof s === 'object' ? s : {};
        if (!('id' in s)) s.id = 'S' + (i + 1);
        if (!('type' in s)) s.type = 'shape';
        if (!('x' in s)) s.x = 0;
        if (!('y' in s)) s.y = 0;
        if (!('r' in s)) s.r = 0;
        if (!('sx' in s)) s.sx = 1;
        if (!('sy' in s)) s.sy = 1;
        if (!('props' in s)) s.props = {};
        return s;
      });

      // 4) colors
      if (!obj.colors || typeof obj.colors !== 'object') {
        obj.colors = { palette: ['#000000', '#ffffff'], currentFill: '#000000', currentStroke: '#000000' };
      } else {
        if (!Array.isArray(obj.colors.palette)) obj.colors.palette = ['#000000', '#ffffff'];
        if (typeof obj.colors.currentFill !== 'string') obj.colors.currentFill = '#000000';
        if (typeof obj.colors.currentStroke !== 'string') obj.colors.currentStroke = '#000000';
      }

      // 5) valori scalar/struct
      if (typeof obj.strokeWidth !== 'number') obj.strokeWidth = 1;
      if (typeof obj.zoom !== 'number' || !isFinite(obj.zoom)) obj.zoom = 1;
      if (typeof obj.unit !== 'string') obj.unit = 'mm';
      if (!Array.isArray(obj.guides)) obj.guides = [];
      if (!('selection' in obj)) obj.selection = null;
      if (!obj.canvas || typeof obj.canvas !== 'object') obj.canvas = { width: 800, height: 600 };
      if (typeof obj.canvas.width !== 'number') obj.canvas.width = 800;
      if (typeof obj.canvas.height !== 'number') obj.canvas.height = 600;
      if (!obj.meta || typeof obj.meta !== 'object') obj.meta = { updatedAt: Date.now() };
      if (typeof obj.meta.updatedAt !== 'number') obj.meta.updatedAt = Date.now();

      return obj;
    }

    // Curăță recursiv orice array din snapshot (scoate undefined / null)
    function sanitizeArraysRec(obj, depth) {
      if (!obj || typeof obj !== 'object' || depth > 5) return obj;
      if (Array.isArray(obj)) {
        obj = obj.filter(Boolean).map(function (el) {
          return sanitizeArraysRec(el, depth + 1);
        });
        return obj;
      }
      for (var k in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;
        obj[k] = sanitizeArraysRec(obj[k], depth + 1);
      }
      return obj;
    }

    // Normalizator complet, folosit la reset/undo/redo
    function normalizeSnapshot(snap) {
      try {
        // clone ușor ca să nu modificăm by-ref dacă apelantul nu vrea
        var s = (typeof structuredClone === 'function')
          ? structuredClone(snap)
          : JSON.parse(JSON.stringify(snap));
        s = sanitizeArraysRec(s, 0);
        s = fillKnownDefaults(s);
        return s;
      } catch (e) {
        console.warn('[normalizeSnapshot] fallback:', e);
        return snap;
      }
    }

    window.__LCS_NORMALIZE__ = { normalizeSnapshot: normalizeSnapshot };
  })();
  </script>
  <!-- Project persistence helpers + SVG export -->
  <script>
  (function(){
    if (window.__LCS_PROJECT_PANEL__) return;
    window.__LCS_PROJECT_PANEL__ = true;

    var STORAGE_KEY = 'LayerCutStudio:autosave';
    var AUTOSAVE_PREF_KEY = STORAGE_KEY + ':enabled';
    var AUTOSAVE_INTERVAL = 60000;

    var statusEl = document.getElementById('lcs-status');
    var autosaveChk = document.getElementById('lcs-autosave');
    var btnSave = document.getElementById('lcs-save');
    var btnLoad = document.getElementById('lcs-load');
    var btnExport = document.getElementById('lcs-export');
    var btnExportSVG = document.getElementById('lcs-export-svg');
    var btnImportBtn = document.getElementById('lcs-import-btn');
    var inputImport = document.getElementById('lcs-import');

    var autosaveEnabled = true;
    var autosaveTimer = null;

    function setStatusMessage(msg){
      if (statusEl) statusEl.textContent = msg;
    }

    function formatTimestamp(ts){
      var d = new Date(ts);
      if (isNaN(d.getTime())) return null;
      try { return d.toLocaleString(); } catch(_){ return d.toISOString(); }
    }

    function setStatusFromTs(ts, suffix){
      if (!statusEl) return;
      if (!ts){
        statusEl.textContent = 'Last saved: never';
        return;
      }
      var label = formatTimestamp(ts);
      if (!label){
        statusEl.textContent = 'Last saved: unknown';
        return;
      }
      statusEl.textContent = 'Last saved: ' + label + (suffix ? ' ' + suffix : '');
    }

    function getSnapshotSafe(){
      try {
        if (typeof window.getSnapshot !== 'function') return null;
        var snap = window.getSnapshot();
        if (!snap || typeof snap !== 'object') return null;
        if (typeof structuredClone === 'function') return structuredClone(snap);
        return JSON.parse(JSON.stringify(snap));
      } catch (e) {
        console.warn('[LCS] getSnapshot failed', e);
        return null;
      }
    }

    function clearAutosaveTimer(){
      if (autosaveTimer){
        clearTimeout(autosaveTimer);
        autosaveTimer = null;
      }
    }

    function autosaveLoop(){
      clearAutosaveTimer();
      if (!autosaveEnabled) return;
      autosaveTimer = setTimeout(function(){
        saveToLocal({ silent:true, tag:'autosave', restart:false });
        autosaveLoop();
      }, AUTOSAVE_INTERVAL);
    }

    function restartAutosaveLoop(){
      clearAutosaveTimer();
      if (autosaveEnabled) autosaveLoop();
    }

    function readSavedStatus(){
      try {
        var raw = localStorage.getItem(STORAGE_KEY);
        if (!raw){
          setStatusFromTs(null);
          return;
        }
        var data = JSON.parse(raw);
        if (data && typeof data.t === 'number') setStatusFromTs(data.t);
        else setStatusFromTs(null);
      } catch (e) {
        console.warn('[LCS] read autosave failed', e);
        setStatusMessage('Last saved: storage unavailable');
      }
    }

    function saveToLocal(opts){
      opts = opts || {};
      var snap = getSnapshotSafe();
      if (!snap){
        if (!opts.silent) setStatusMessage('Last saved: unavailable (no snapshot)');
        return false;
      }
      var payload = { t: Date.now(), v: 1, snap: snap };
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      } catch (e) {
        console.warn('[LCS] save failed', e);
        if (!opts.silent) alert('Save failed. Unable to access localStorage.');
        setStatusMessage('Last saved: storage error');
        return false;
      }
      var suffix = '';
      if (opts.suffix) suffix = opts.suffix;
      else if (opts.tag) suffix = '(' + opts.tag + ')';
      setStatusFromTs(payload.t, suffix);
      if (opts.restart !== false) restartAutosaveLoop();
      try {
        window.dispatchEvent(new CustomEvent('lcs:saved', { detail:{ ts: payload.t, reason: opts.tag || 'manual' } }));
      } catch(_){ }
      return true;
    }

    function cloneSnapshot(snap){
      if (!snap || typeof snap !== 'object') return null;
      try {
        return (typeof structuredClone === 'function') ? structuredClone(snap) : JSON.parse(JSON.stringify(snap));
      } catch (e) {
        console.warn('[LCS] clone snapshot fallback', e);
        try { return JSON.parse(JSON.stringify(snap)); } catch(_){ return snap; }
      }
    }

    function applySnapshotData(snap, tag){
      if (!snap || typeof snap !== 'object') throw new Error('Snapshot missing');
      if (typeof window.applySnapshot !== 'function') throw new Error('applySnapshot unavailable');
      var copy = cloneSnapshot(snap);
      window.applySnapshot(copy);
      var ts = Date.now();
      setStatusFromTs(ts, tag ? '(' + tag + ')' : '(imported)');
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify({ t: ts, v: 1, snap: copy }));
      } catch (e) {
        console.warn('[LCS] store imported snapshot failed', e);
      }
      restartAutosaveLoop();
      return true;
    }

    function importSnapshotPayload(raw, opts){
      opts = opts || {};
      if (!raw) throw new Error('Empty payload');
      if (typeof Blob !== 'undefined' && raw instanceof Blob){
        var reader = new FileReader();
        reader.onload = function(){
          try {
            importSnapshotPayload(reader.result, opts);
          } catch (err) {
            console.warn('[LCS] import failed', err);
            alert('Import failed: ' + (err && err.message ? err.message : 'invalid file'));
          }
        };
        reader.onerror = function(){
          alert('Import failed. Could not read file.');
        };
        reader.readAsText(raw);
        return true;
      }
      var data = raw;
      if (typeof raw === 'string'){
        data = JSON.parse(raw);
      }
      if (data && typeof data === 'object'){
        var snap = data.snap || data.snapshot || data.data || data.snapShot || data;
        return applySnapshotData(snap, opts.tag || 'imported');
      }
      throw new Error('Unsupported snapshot payload');
    }

    function loadFromLocal(){
      var raw;
      try {
        raw = localStorage.getItem(STORAGE_KEY);
      } catch (e) {
        alert('Cannot access autosave storage.');
        return;
      }
      if (!raw){
        alert('No autosave found.');
        return;
      }
      var data;
      try { data = JSON.parse(raw); }
      catch(_){ alert('Autosave data is corrupted.'); return; }
      var snap = data && (data.snap || data.snapshot || data.data);
      if (!snap || typeof snap !== 'object'){ alert('Autosave snapshot missing.'); return; }
      try {
        applySnapshotData(snap, 'loaded');
        if (typeof window.pushHistory === 'function'){
          try { window.pushHistory('load-autosave'); } catch(_){ }
        }
      } catch (e) {
        console.warn('[LCS] load autosave failed', e);
        alert('Failed to apply autosave snapshot.');
      }
    }

    function exportFile(){
      try {
        var snap = getSnapshotSafe();
        if (!snap){
          alert('Nothing to export yet.');
          return;
        }
        var data = { t: Date.now(), v: 1, snap: snap };
        var blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = 'layercut-project.lcs';
        document.body.appendChild(a);
        a.click();
        setTimeout(function(){ URL.revokeObjectURL(url); a.remove(); }, 0);
      } catch (e) {
        console.warn('[LCS] export failed', e);
        alert('Export failed. See console for details.');
      }
    }

    function exportSVGForLaser(){
      try {
        var unit = 'mm';
        try {
          var snap = (typeof window.getSnapshot === 'function') ? window.getSnapshot() : null;
          if (snap && typeof snap.unit === 'string') unit = snap.unit;
        } catch(_){ }
        unit = (unit === 'in' || unit === 'inch' || unit === 'inches') ? 'in' : 'mm';
        var PX_TO_MM = 25.4 / 96;
        var PX_TO_IN = 1 / 96;
        var px2u = unit === 'in' ? PX_TO_IN : PX_TO_MM;

        var svgs = Array.from(document.querySelectorAll('svg'));
        if (!svgs.length){ alert('No SVG found to export.'); return; }
        function areaOf(svg){
          var vb = (svg.getAttribute('viewBox')||'').trim().split(/\s+/).map(Number);
          if (vb.length === 4 && vb.every(function(n){ return Number.isFinite(n); })) return Math.abs(vb[2] * vb[3]);
          var r = svg.getBoundingClientRect();
          return Math.abs((r.width||0) * (r.height||0));
        }
        var main = svgs.slice().sort(function(a,b){ return areaOf(b) - areaOf(a); })[0];
        if (!main){ alert('No SVG found to export.'); return; }
        var clone = main.cloneNode(true);

        var removeSel = '[data-export="false"],[data-export=false],.grid,.guide,.guides,.handle,.handles,.selection,.ui';
        try {
          clone.querySelectorAll(removeSel).forEach(function(el){ el.remove(); });
        } catch(_){ }

        var vbAttr = (main.getAttribute('viewBox')||'').trim();
        var vbParts = vbAttr ? vbAttr.split(/\s+/).map(Number) : [];
        var w = 0, h = 0;
        if (vbParts.length === 4 && vbParts.every(function(n){ return Number.isFinite(n); })){
          w = vbParts[2];
          h = vbParts[3];
          clone.setAttribute('viewBox', vbParts.join(' '));
        } else {
          try {
            var bb = main.getBBox();
            if (bb && Number.isFinite(bb.width) && Number.isFinite(bb.height)){
              w = bb.width;
              h = bb.height;
              clone.setAttribute('viewBox', [bb.x, bb.y, bb.width, bb.height].join(' '));
            }
          } catch(_){ }
        }
        if (w > 0 && h > 0){
          clone.setAttribute('width', (w * px2u).toFixed(3) + unit);
          clone.setAttribute('height', (h * px2u).toFixed(3) + unit);
        } else {
          clone.removeAttribute('width');
          clone.removeAttribute('height');
        }

        clone.querySelectorAll('*').forEach(function(el){
          try {
            var sw = el.getAttribute && el.getAttribute('stroke-width');
            if (sw && /^-?\d+(\.\d+)?/.test(sw)){
              var val = parseFloat(sw);
              if (Number.isFinite(val)) el.setAttribute('stroke-width', (val * px2u).toFixed(3) + unit);
            }
            var tag = (el.tagName||'').toLowerCase();
            if (tag === 'path'){
              if (!el.getAttribute('stroke-linejoin')) el.setAttribute('stroke-linejoin','round');
              if (!el.getAttribute('stroke-linecap')) el.setAttribute('stroke-linecap','round');
            }
          } catch(_){ }
        });

        var xmlHead = '<?xml version="1.0" encoding="UTF-8"?>\n';
        var meta = '<!-- Exported by LayerCut Studio • unit=' + unit + ' • ' + new Date().toISOString() + ' -->\n';
        var serializer = new XMLSerializer();
        var svgString = serializer.serializeToString(clone);
        if (!/xmlns=/.test(svgString)) svgString = svgString.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
        var blob = new Blob([xmlHead + meta + svgString], { type: 'image/svg+xml' });
        var url = URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = url;
        link.download = 'layercut-export.svg';
        document.body.appendChild(link);
        link.click();
        setTimeout(function(){ URL.revokeObjectURL(url); link.remove(); }, 0);
      } catch (e) {
        console.warn('[LCS] exportSVG failed', e);
        alert('Export SVG failed. See console for details.');
      }
    }

    function handleFileInput(ev){
      try {
        var file = ev && ev.target && ev.target.files ? ev.target.files[0] : null;
        if (file) importSnapshotPayload(file, { tag:'imported' });
      } catch(e){
        console.warn('[LCS] import handler failed', e);
      } finally {
        if (ev && ev.target) ev.target.value = '';
      }
    }

    function setAutosave(flag){
      autosaveEnabled = !!flag;
      if (autosaveChk) autosaveChk.checked = autosaveEnabled;
      try { localStorage.setItem(AUTOSAVE_PREF_KEY, autosaveEnabled ? '1' : '0'); } catch(_){ }
      if (autosaveEnabled) restartAutosaveLoop();
      else clearAutosaveTimer();
    }

    // Hook buttons
    if (btnSave) btnSave.onclick = function(){ saveToLocal(); };
    if (btnLoad) btnLoad.onclick = function(){ loadFromLocal(); };
    if (btnExport) btnExport.onclick = exportFile;
    if (btnExportSVG) btnExportSVG.onclick = exportSVGForLaser;
    if (btnImportBtn) btnImportBtn.onclick = function(){ if (inputImport) inputImport.click(); };
    if (inputImport) inputImport.addEventListener('change', handleFileInput);
    if (autosaveChk) autosaveChk.addEventListener('change', function(){ setAutosave(autosaveChk.checked); });

    // Keyboard shortcuts (Ctrl+S / Ctrl+O)
    window.addEventListener('keydown', function(e){
      if (!e) return;
      if (!e.ctrlKey && !e.metaKey) return;
      var key = (e.key||'').toLowerCase();
      if (key === 's'){
        e.preventDefault();
        saveToLocal();
      } else if (key === 'o'){
        e.preventDefault();
        if (inputImport) inputImport.click();
      }
    }, { passive:false });

    window.addEventListener('beforeunload', function(){
      if (autosaveEnabled) saveToLocal({ silent:true, tag:'autosave', restart:false });
    });

    // Initial state
    (function(){
      var pref = null;
      try { pref = localStorage.getItem(AUTOSAVE_PREF_KEY); } catch(_){ }
      if (pref === '0') autosaveEnabled = false;
      else if (pref === '1') autosaveEnabled = true;
      if (autosaveChk) autosaveChk.checked = autosaveEnabled;
    })();

    readSavedStatus();
    if (autosaveEnabled) autosaveLoop();

    var api = window.LCS_Project || {};
    api.saveToLocal = saveToLocal;
    api.loadFromLocal = loadFromLocal;
    api.export = exportFile;
    api.exportSVG = exportSVGForLaser;
    api.importFile = function(payload){
      try { return importSnapshotPayload(payload, { tag:'imported' }); }
      catch(e){ console.warn('[LCS] importFile failed', e); return false; }
    };
    api.setAutosave = function(v){ setAutosave(v); };
    api.isAutosave = function(){ return !!autosaveEnabled; };
    api.getSnapshotSafe = getSnapshotSafe;
    window.LCS_Project = api;
  })();
  </script>
  <!-- Outline smoothing: enforce round joins/caps + safe offset options -->
  <script>
  (function(){
    if (window.__LCS_OUTLINE_FIX__) return;
    window.__LCS_OUTLINE_FIX__ = true;

    // 1) Canvas 2D: forțează lineJoin/lineCap/miterLimit la fiecare stroke/text
    try {
      if (window.CanvasRenderingContext2D && CanvasRenderingContext2D.prototype) {
        var P = CanvasRenderingContext2D.prototype;
        var setRound = function(ctx){
          try{
            if (ctx.lineJoin !== 'round') ctx.lineJoin = 'round';
            if (ctx.lineCap  !== 'round') ctx.lineCap  = 'round';
            if (!(ctx.miterLimit <= 3))   ctx.miterLimit = 2.5;
          }catch(_){ }
        };
        var _stroke = P.stroke;
        P.stroke = function(){ setRound(this); return _stroke.apply(this, arguments); };
        var _strokeText = P.strokeText;
        if (_strokeText) P.strokeText = function(){ setRound(this); return _strokeText.apply(this, arguments); };
        var _fillText = P.fillText;
        if (_fillText)   P.fillText   = function(){ setRound(this); return _fillText.apply(this, arguments); };
      }
    } catch(_) {}

    // 2) SVG: aplică atributele pe orice path (inclusiv pe cele adăugate ulterior)
    function enforceSvgRound(root){
      try {
        (root || document).querySelectorAll('svg path').forEach(function(p){
          p.setAttribute('stroke-linejoin','round');
          p.setAttribute('stroke-linecap','round');
        });
      } catch(_) {}
    }
    enforceSvgRound(document);
    try {
      var mo = new MutationObserver(function(muts){
        muts.forEach(function(m){
          m.addedNodes && m.addedNodes.forEach(function(n){
            if (n && n.nodeType===1){
              enforceSvgRound(n);
              if (n.shadowRoot) enforceSvgRound(n.shadowRoot);
            }
          });
        });
      });
      mo.observe(document.documentElement, { childList:true, subtree:true });
      setTimeout(function(){ try{ mo.disconnect(); }catch(_){ } }, 8000); // nu ținem observer-ul la nesfârșit
    } catch(_) {}

    // 3) Dacă există o funcție de offset globală, o împachetăm cu opțiuni sigure
    try {
      if (typeof window.offsetPathToPolys === 'function' && !window.offsetPathToPolys.__wrappedFix){
        var _origOffset = window.offsetPathToPolys;
        window.offsetPathToPolys = function(path, opts){
          opts = Object.assign(
            { join:'round', cap:'round', miterLimit:2.5, simplify:true, simplifyTolerance:0.15 },
            opts || {}
          );
          return _origOffset(path, opts);
        };
        window.offsetPathToPolys.__wrappedFix = true;
      }
    } catch(_) {}

    // 4) Când se apasă butonul "Set" la grosimi, rulează fixul + push coalesced
    document.addEventListener('click', function(e){
      var t = e.target;
      if (!t || t.tagName !== 'BUTTON') return;
      var label = (t.textContent || '').trim().toLowerCase();
      if (label === 'set') {
        // după ce aplicația a actualizat starea, re-enforce pe SVG și autosave în istoric
        setTimeout(function(){
          enforceSvgRound(document);
          if (typeof window.pushHistoryCoalesced === 'function') {
            window.pushHistoryCoalesced('thickness-change', 400);
          } else if (window.LCS && typeof window.LCS.push === 'function') {
            window.LCS.push('thickness-change');
          }
        }, 0);
      }
    }, true);
  })();
  </script>
  <!-- Cleanup: remove all dev/test banners (Codex & Kilo) -->
  <script>
  (function(){
    try{
      // remove our test banners by id (if present)
      ['#codex-dev-banner', '#codex-banner'].forEach(function(sel){
        document.querySelectorAll(sel).forEach(function(el){ el.remove(); });
      });
      // remove any element that contains the text "KILO PATCH OK"
      var re = /KILO\s*PATCH\s*OK/i;
      var walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null);
      var toRemove = [];
      while (walker.nextNode()) {
        var el = walker.currentNode;
        if (el && el.textContent && re.test(el.textContent)) toRemove.push(el);
      }
      toRemove.forEach(function(el){ if (el && el.parentNode) el.parentNode.removeChild(el); });
    } catch(e) { /* silent */ }
  })();
  </script>
  <!-- Outline Smoother v2: CSS round joins + Catmull-Rom smoothing on SVG paths -->
  <style id="lcs-outline-style">
    svg { shape-rendering: geometricPrecision; }
    svg path { stroke-linejoin: round; stroke-linecap: round; }
  </style>
  <script>
  (function(){
    if (window.__LCS_OUTLINE_SMOOTHER__) return; // evită dublarea
    window.__LCS_OUTLINE_SMOOTHER__ = true;

    // === utilitare ===
    function samplePath(el, maxSamples){
      if (!(el && el.getTotalLength)) return null;
      var len = el.getTotalLength();
      var n = Math.max(32, Math.min(maxSamples||800, Math.round(len/3))); // 3px pas
      var pts = [];
      for (var i=0;i<=n;i++){
        var p = el.getPointAtLength((i/n)*len);
        pts.push([p.x, p.y]);
      }
      return pts;
    }
    // Catmull-Rom (uniform, s=1) → cubic Bezier pe segment [p1,p2]
    function catmullRomToBezier(p0,p1,p2,p3){
      var s = 1; // tensiune
      var c1x = p1[0] + (p2[0]-p0[0]) / 6 * s;
      var c1y = p1[1] + (p2[1]-p0[1]) / 6 * s;
      var c2x = p2[0] - (p3[0]-p1[0]) / 6 * s;
      var c2y = p2[1] - (p3[1]-p1[1]) / 6 * s;
      return [[c1x,c1y],[c2x,c2y],[p2[0],p2[1]]];
    }
    function pointsToCubicPath(pts, closed){
      if (!pts || pts.length < 2) return '';
      // dacă path-ul e închis, duplicăm capetele pentru continuitate
      var P = pts.slice();
      if (closed){
        P.unshift(pts[pts.length-2] || pts[0]);
        P.unshift(pts[pts.length-1] || pts[0]);
        P.push(pts[0], pts[1]||pts[0]);
      } else {
        // capete: duplicate p0/pn pentru cond. de margine
        P.unshift(pts[0]); P.push(pts[pts.length-1]);
      }
      var d = 'M ' + pts[0][0] + ' ' + pts[0][1];
      for (var i=0; i < P.length-3; i++){
        var b = catmullRomToBezier(P[i], P[i+1], P[i+2], P[i+3]);
        d += ' C ' + b[0][0] + ' ' + b[0][1] + ' ' + b[1][0] + ' ' + b[1][1] + ' ' + b[2][0] + ' ' + b[2][1];
      }
      if (closed) d += ' Z';
      return d;
    }
    function isClosed(el){
      try { return /z\s*$/i.test((el.getAttribute('d')||'').trim()); } catch(_) { return false; }
    }
    function smoothOnePath(el){
      if (!(el && el.tagName === 'path')) return;
      if (el.dataset && el.dataset.smoothed === '1') return; // o singură dată
      var pts = samplePath(el, 900);
      if (!pts || pts.length < 4) return;
      var closed = isClosed(el);
      var d = pointsToCubicPath(pts, closed);
      if (d && d.length > 0){
        el.setAttribute('d', d);
        el.setAttribute('stroke-linejoin','round');
        el.setAttribute('stroke-linecap','round');
        el.dataset.smoothed = '1';
      }
    }
    function smoothAllPaths(root){
      try {
        (root || document).querySelectorAll('svg path').forEach(smoothOnePath);
      } catch(_){ }
    }
    // rulează cu un mic debounce după schimbări mari
    var _tm = 0;
    function scheduleSmooth(ms){
      clearTimeout(_tm);
      _tm = setTimeout(function(){ smoothAllPaths(document); }, ms||40);
    }

    // 1) inițial
    if (document.readyState === 'loading'){
      document.addEventListener('DOMContentLoaded', function(){ scheduleSmooth(10); });
    } else {
      scheduleSmooth(10);
    }

    // 2) după apăsarea butoanelor "Set"
    document.addEventListener('click', function(e){
      var t = e.target;
      if (!t || t.tagName !== 'BUTTON') return;
      var label = (t.textContent || '').trim().toLowerCase();
      if (label === 'set'){ scheduleSmooth(30); }
    }, true);

    // 3) după undo/redo/reset (eveniment din managerul nostru)
    window.addEventListener('lcs:state-applied', function(){ scheduleSmooth(30); });

    // 4) dacă DOM-ul adaugă SVG-uri noi, le netezim câteva secunde
    try {
      var mo = new MutationObserver(function(muts){
        var touched = false;
        muts.forEach(function(m){
          m.addedNodes && m.addedNodes.forEach(function(n){
            if (n && n.nodeType===1){
              if (n.tagName && n.tagName.toLowerCase()==='path') touched = true;
              if (n.querySelector && n.querySelector('svg path')) touched = true;
            }
          });
        });
        if (touched) scheduleSmooth(30);
      });
      mo.observe(document.documentElement, { childList:true, subtree:true });
      setTimeout(function(){ try{ mo.disconnect(); }catch(_){ } }, 6000);
    } catch(_){ }

    console.info('[LCS] Outline Smoother v2 active');
  })();
  </script>
  <!-- UI test badge (poți șterge ulterior) -->
  <div id="lcs-test-badge" style="position:fixed;left:12px;bottom:12px;z-index:99999;background:#10b981;color:#fff;padding:6px 10px;border-radius:9999px;font:600 12px/1 system-ui,Segoe UI,Roboto;box-shadow:0 2px 8px rgba(0,0,0,.15);">
    ✅ Build OK • test patch
  </div>
  <!-- Undo/Redo clasic + auto-push coalesced pentru acțiunile UI -->
  <script>
  (function(){
    // nu instala de 2 ori (HMR/refresh parțial)
    if (window.__LCS_UNDO_REDO_PATCH__) return;
    window.__LCS_UNDO_REDO_PATCH__ = true;

    // utilitare
    var hasStructured = (typeof structuredClone === 'function');
    function dclone(o){ try { return hasStructured ? structuredClone(o) : JSON.parse(JSON.stringify(o)); } catch(e){ return o; } }
    function isEditable(el){
      if (!el) return false;
      var t = (el.tagName||'').toLowerCase();
      return ['input','textarea','select'].includes(t) || !!el.isContentEditable;
    }

    // 1) History adapters + push inițial
    (function bindAdaptersWithInit(){
      if (!window.LCS) window.LCS = {};
      var LCS = window.LCS;
      // dacă ai deja managerul tău, îl folosim; altfel cream unul minimalist
      if (!LCS.history) {
        function HM(){ this.stack=[]; this.index=-1; this._a={getSnapshot:function(){return{};},applySnapshot:function(){}}; }
        HM.prototype.setAdapters = function(a){ this._a=a||this._a; };
        HM.prototype.push = function(){ var snap=dclone(this._a.getSnapshot()||{}); if(this.index < this.stack.length-1) this.stack=this.stack.slice(0,this.index+1); this.stack.push(snap); this.index=this.stack.length-1; };
        HM.prototype.canUndo = function(){ return this.index>0; };
        HM.prototype.canRedo = function(){ return this.index>=0 && this.index < this.stack.length-1; };
        HM.prototype.undo = function(){ if(!this.canUndo())return; this.index--; this._a.applySnapshot(dclone(this.stack[this.index])); };
        HM.prototype.redo = function(){ if(!this.canRedo())return; this.index++; this._a.applySnapshot(dclone(this.stack[this.index])); };
        LCS.history = new HM();
      }
      function tryBind(){
        if (LCS.__adaptersBoundUndoRedo) return true;
        if (typeof window.getSnapshot === 'function' && typeof window.applySnapshot === 'function') {
          LCS.history.setAdapters({
            getSnapshot: function(){ return window.getSnapshot() || {}; },
            applySnapshot: function(snap){ window.applySnapshot(snap); }
          });
          if (!LCS.__pushedInit) { try { LCS.history.push('init'); } catch(_){ } LCS.__pushedInit = true; }
          LCS.__adaptersBoundUndoRedo = true;
          return true;
        }
        return false;
      }
      if (!tryBind()){
        var tries = 0, iv = setInterval(function(){ tries++; if (tryBind() || tries>200) clearInterval(iv); }, 50);
      }
    })();

    // 2) Shortcuts: Ctrl+Z / Ctrl+Shift+Z / Ctrl+Y  (capturing + preventDefault)
    if (!window.__LCS_KEYS_BOUND_CLASSIC__){
      window.__LCS_KEYS_BOUND_CLASSIC__ = true;
      window.addEventListener('keydown', function(e){
        var ctrl = e.ctrlKey || e.metaKey;
        if (!ctrl) return;
        // lasă browserul să facă undo în input/textarea
        if (isEditable(e.target)) return;
        var k = (e.key||'').toLowerCase();
        var sh = !!e.shiftKey;
        if (k === 'z' && !sh){
          if (window.LCS && window.LCS.history && window.LCS.history.canUndo()){
            e.preventDefault();
            try { window.LCS.history.undo(); } catch(_){ }
          }
        } else if ((k === 'z' && sh) || k === 'y'){
          if (window.LCS && window.LCS.history && window.LCS.history.canRedo()){
            e.preventDefault();
            try { window.LCS.history.redo(); } catch(_){ }
          }
        }
      }, true); // capture ca să nu fie blocat de alți listeners
    }

    // 3) Auto-push coalesced la acțiuni UI comune (input/change/click pe butoane)
    (function autoPushUI(){
      var t = 0;
      function schedule(reason){
        if (!window.LCS || !window.LCS.history) return;
        clearTimeout(t);
        t = setTimeout(function(){
          try { window.LCS.history.push(reason||'ui-change'); } catch(_){ }
        }, 220); // coalesced ~0.2s
      }
      // input & change pe panoul de opțiuni
      document.addEventListener('input', function(e){
        var el = e.target;
        if (!el) return;
        // să nu împingem la fiecare tastă din text inputs — doar la sliders/colors checkboxes
        var type = (el.type||'').toLowerCase();
        if (['range','color','checkbox','radio','number'].includes(type)) schedule('ui-input');
      }, true);
      document.addEventListener('change', function(){ schedule('ui-change'); }, true);
      // click pe butoane „Set”, „Reset”, „Undo/Redo” etc. → împinge după ce acțiunea aplică state-ul
      document.addEventListener('click', function(e){
        var t = e.target;
        if (!t || t.tagName!=='BUTTON') return;
        var label = (t.textContent||'').toLowerCase().trim();
        if (['set','reset','apply','ok','done','aplica','reseteaza','undo','redo'].some(function(s){return label===s;})){
          setTimeout(function(){ schedule('ui-click'); }, 0);
        }
      }, true);
    })();

    // 4) API global pentru butoanele existente (dacă le ai în UI)
    window.undo = function(){ try { if (window.LCS.history.canUndo()) window.LCS.history.undo(); } catch(_){ } };
    window.redo = function(){ try { if (window.LCS.history.canRedo()) window.LCS.history.redo(); } catch(_){ } };
    window.pushHistory = function(){ try { window.LCS.history.push('manual'); } catch(_){ } };
  })();
  </script>
  <!-- Align & Distribute (floating toolbar) -->
  <style>
    #lcs-alignbar{position:fixed;right:16px;bottom:84px;z-index:99990;background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.15);padding:8px}
    #lcs-alignbar .row{display:flex;gap:6px;margin:6px 4px}
    #lcs-alignbar button{width:34px;height:34px;border:1px solid #e5e7eb;border-radius:8px;background:#fff;cursor:pointer;font:600 14px/1 system-ui}
    #lcs-alignbar button:hover{background:#f3f4f6}
    #lcs-alignbar .ttl{font:700 12px/1 system-ui;color:#374151;margin:2px 4px 0}
  </style>
  <div id="lcs-alignbar" title="Align & Distribute">
    <div class="ttl">Align</div>
    <div class="row">
      <button id="al-left"  title="Align Left">⟸</button>
      <button id="al-center" title="Align Center">↔</button>
      <button id="al-right" title="Align Right">⟹</button>
    </div>
    <div class="row">
      <button id="al-top" title="Align Top">⟰</button>
      <button id="al-middle" title="Align Middle">↕</button>
      <button id="al-bottom" title="Align Bottom">⟱</button>
    </div>
    <div class="ttl">Distribute</div>
    <div class="row">
      <button id="ds-h" title="Distribute Horizontally">═╪═</button>
      <button id="ds-v" title="Distribute Vertically">║╫║</button>
    </div>
  </div>
  <script>
  (function(){
    if (window.__LCS_ALIGN_INSTALLED__) return; window.__LCS_ALIGN_INSTALLED__=true;

    // ------- helpers -------
    function qsa(sel,root){ return Array.from((root||document).querySelectorAll(sel)); }
    function editable(el){ if(!el) return false; const t=(el.tagName||'').toLowerCase(); return ['input','textarea','select'].includes(t)||!!el.isContentEditable; }
    function getMainSVG(){
      const svgs = qsa('svg');
      if (!svgs.length) return null;
      function area(svg){
        const vb=(svg.getAttribute('viewBox')||'').trim().split(/\s+/).map(Number);
        if (vb.length===4 && vb.every(isFinite)) return Math.abs(vb[2]*vb[3]);
        const r=svg.getBoundingClientRect(); return Math.abs(r.width*r.height)||0;
      }
      return svgs.sort((a,b)=>area(b)-area(a))[0];
    }
    function getBBoxSafe(el){
      try{ const b=el.getBBox(); return {x:b.x,y:b.y,w:b.width,h:b.height,cx:b.x+b.width/2,cy:b.y+b.height/2}; }catch(_){ return null; }
    }
    function parseTransform(tr){
      tr=tr||''; const m=tr.match(/translate\(([^)]+)\)/i);
      if(!m) return {tx:0,ty:0,rest:tr};
      const parts=m[1].split(/[, ]+/).map(Number); return {tx:parts[0]||0,ty:parts[1]||0,rest:tr.replace(m[0],'').trim()};
    }
    function setTranslate(el,dx,dy){
      const t=parseTransform(el.getAttribute('transform'));
      const ntx=(t.tx||0)+dx, nty=(t.ty||0)+dy;
      const rest=t.rest ? (t.rest+' ') : '';
      el.setAttribute('transform', rest + 'translate(' + ntx + ',' + nty + ')');
    }

    // ------- selection detection -------
    function selectedDom(){
      const root=getMainSVG()||document;
      let els = qsa('[data-selected="1"]',root);
      if(!els.length) els = qsa('[aria-selected="true"]',root);
      if(!els.length) els = qsa('.selected',root);
      // fallback: dacă nu e nimic marcat, ia elementele cu data-lcs-id prezente în selection din state
      if(!els.length){
        try{
          if (typeof window.getSnapshot==='function'){
            const s=window.getSnapshot()||{};
            const sel = Array.isArray(s.selection) ? s.selection : (s.selection ? [s.selection] : []);
            if (sel.length){
              sel.forEach(id=>{
                const cand = document.querySelector('[data-lcs-id="'+id+'"], [data-id="'+id+'"], #'+CSS.escape(id));
                if (cand) els.push(cand);
              });
            }
          }
        }catch(_){ }
      }
      return els;
    }

    // ------- state align (preferred) -------
    function tryAlignInState(kind){
      try{
        if (typeof window.getSnapshot!=='function' || typeof window.applySnapshot!=='function') return false;
        const snap = window.getSnapshot() || {};
        const sel = Array.isArray(snap.selection) ? snap.selection : (snap.selection ? [snap.selection] : []);
        if (!sel.length) return false;
        // Colectează elemente candidate din snap (stickers / layers items cu id)
        const items = [];
        function addIf(obj){ if(!obj) return; const id=obj.id||obj.key||obj.uuid; if(id && sel.includes(id)) items.push(obj); }
        if (Array.isArray(snap.stickers)) snap.stickers.forEach(addIf);
        if (Array.isArray(snap.layers))   snap.layers.forEach(addIf);
        // dacă nu găsim după id, ieșim pe fallback
        if (items.length<2) return false;
        // avem nevoie de poziții x/y (dacă lipsesc, fallback DOM)
        if (items.some(it=>typeof it.x!=='number' || typeof it.y!=='number')) return false;
        // bounding box aproximat (fără w/h – aliniem pe x/y sau centru dacă există w/h)
        const xs = items.map(it=>it.x), ys = items.map(it=>it.y);
        const minX=Math.min.apply(null,xs), maxX=Math.max.apply(null,xs), minY=Math.min.apply(null,ys), maxY=Math.max.apply(null,ys);
        const cx=(minX+maxX)/2, cy=(minY+maxY)/2;
        items.forEach(it=>{
          if (kind==='left')   it.x = minX;
          if (kind==='center') it.x = cx;
          if (kind==='right')  it.x = maxX;
          if (kind==='top')    it.y = minY;
          if (kind==='middle') it.y = cy;
          if (kind==='bottom') it.y = maxY;
        });
        window.applySnapshot(snap);
        if (window.LCS && window.LCS.history) { try{ window.LCS.history.push('align-'+kind); }catch(_){ } }
        return true;
      }catch(_){ return false; }
    }

    // ------- DOM align fallback -------
    function alignDom(kind){
      const els = selectedDom();
      if (els.length<2) return;
      // calculează bounding box comun
      const boxes = els.map(el=>({el:el, bb:getBBoxSafe(el)})).filter(x=>!!x.bb);
      if (boxes.length<2) return;
      const minX = Math.min.apply(null, boxes.map(b=>b.bb.x));
      const maxX = Math.max.apply(null, boxes.map(b=>b.bb.x + b.bb.w));
      const minY = Math.min.apply(null, boxes.map(b=>b.bb.y));
      const maxY = Math.max.apply(null, boxes.map(b=>b.bb.y + b.bb.h));
      const cX = (minX+maxX)/2, cY=(minY+maxY)/2;
      boxes.forEach(b=>{
        const {x,y,w,h,cx,cy}=b.bb;
        let dx=0, dy=0;
        if (kind==='left')   dx = minX - x;
        if (kind==='center') dx = cX - cx;
        if (kind==='right')  dx = maxX - (x+w);
        if (kind==='top')    dy = minY - y;
        if (kind==='middle') dy = cY - cy;
        if (kind==='bottom') dy = maxY - (y+h);
        if (dx||dy) setTranslate(b.el, dx, dy);
      });
      if (window.LCS && window.LCS.history) { try{ window.LCS.history.push('align-'+kind); }catch(_){ } }
    }

    // ------- Distribute (DOM; funcționează pe selecția curentă) -------
    function distributeDom(axis){ // 'h' or 'v'
      const els = selectedDom();
      if (els.length<3) return;
      const boxes = els.map(el=>({el:el, bb:getBBoxSafe(el)})).filter(x=>!!x.bb);
      if (boxes.length<3) return;
      if (axis==='h'){
        boxes.sort((a,b)=>a.bb.cx-b.bb.cx);
        const min = Math.min.apply(null, boxes.map(b=>b.bb.x));
        const max = Math.max.apply(null, boxes.map(b=>b.bb.x + b.bb.w));
        const totalW = boxes.reduce((s,b)=>s+b.bb.w,0);
        const gaps = (boxes.length-1);
        const gap = (max-min-totalW)/Math.max(1,gaps);
        let cursor = min;
        boxes.forEach((b)=>{
          const dx = cursor - b.bb.x;
          if (dx) setTranslate(b.el, dx, 0);
          cursor += b.bb.w + gap;
        });
      } else {
        boxes.sort((a,b)=>a.bb.cy-b.bb.cy);
        const min = Math.min.apply(null, boxes.map(b=>b.bb.y));
        const max = Math.max.apply(null, boxes.map(b=>b.bb.y + b.bb.h));
        const totalH = boxes.reduce((s,b)=>s+b.bb.h,0);
        const gaps = (boxes.length-1);
        const gap = (max-min-totalH)/Math.max(1,gaps);
        let cursor = min;
        boxes.forEach((b)=>{
          const dy = cursor - b.bb.y;
          if (dy) setTranslate(b.el, 0, dy);
          cursor += b.bb.h + gap;
        });
      }
      if (window.LCS && window.LCS.history) { try{ window.LCS.history.push('distribute-'+axis); }catch(_){ } }
    }

    // ------- wiring -------
    function doAlign(kind){
      if (!tryAlignInState(kind)) alignDom(kind);
    }
    const $ = (id)=>document.getElementById(id);
    const map = {
      'al-left':()=>doAlign('left'),
      'al-center':()=>doAlign('center'),
      'al-right':()=>doAlign('right'),
      'al-top':()=>doAlign('top'),
      'al-middle':()=>doAlign('middle'),
      'al-bottom':()=>doAlign('bottom'),
      'ds-h':()=>distributeDom('h'),
      'ds-v':()=>distributeDom('v'),
    };
    Object.keys(map).forEach(id=>{ const el=$(id); if(el) el.onclick=map[id]; });

    // Shortcuts: Shift+A deschide focus pe toolbar (nu e modal), Alt+Arrow pentru align rapid
    window.addEventListener('keydown', function(e){
      if (editable(e.target)) return;
      const k=(e.key||'').toLowerCase();
      if (e.shiftKey && k==='a'){ e.preventDefault(); try{ document.getElementById('al-center').focus(); }catch(_){ } }
      if (e.altKey){
        if (k==='arrowleft'){ e.preventDefault(); doAlign('left'); }
        if (k==='arrowright'){ e.preventDefault(); doAlign('right'); }
        if (k==='arrowup'){ e.preventDefault(); doAlign('top'); }
        if (k==='arrowdown'){ e.preventDefault(); doAlign('bottom'); }
      }
    }, {passive:false});
  })();
  </script>
  <!-- Command Palette (Ctrl+K) -->
  <style>
    #lcs-cmdk { display:none; position:fixed; inset:0; z-index:99998; background:rgba(0,0,0,.35); align-items:flex-start; justify-content:center; padding-top:10vh; }
    #lcs-cmdk .box { width:min(720px,92vw); background:#fff; border-radius:12px; box-shadow:0 10px 40px rgba(0,0,0,.35); overflow:hidden; }
    #lcs-cmdk input { width:100%; padding:14px 16px; border:0; outline:none; font:500 16px/1.2 system-ui,Segoe UI,Roboto; border-bottom:1px solid #eee; }
    #lcs-cmdk ul { list-style:none; margin:0; padding:6px; max-height:50vh; overflow:auto; }
    #lcs-cmdk li { display:flex; justify-content:space-between; align-items:center; gap:12px; padding:10px 12px; border-radius:8px; cursor:pointer; }
    #lcs-cmdk li:hover, #lcs-cmdk li.active { background:#f3f4f6; }
    #lcs-cmdk small.kbd { font:600 11px/1 system-ui; background:#eef2ff; color:#1f2937; padding:3px 6px; border-radius:6px; border:1px solid #e5e7eb; }
  </style>
  <div id="lcs-cmdk">
    <div class="box">
      <input id="lcs-cmdk-q" type="text" placeholder="Type a command… (Esc to close)" autocomplete="off" />
      <ul id="lcs-cmdk-list"></ul>
    </div>
  </div>
  <script>
  (function(){
    if (window.__LCS_CMDK__) return; window.__LCS_CMDK__ = true;
    var wrap = document.getElementById('lcs-cmdk');
    var q = document.getElementById('lcs-cmdk-q');
    var list = document.getElementById('lcs-cmdk-list');

    function exists(fn){ return typeof fn === 'function'; }
    function run(cmd){
      try { cmd && cmd.action && cmd.action(); } catch(e){ console.warn('[cmdk]', e); }
      close();
    }
    function open(){ wrap.style.display='flex'; q.value=''; render(items); setTimeout(function(){ q.focus(); }, 0); }
    function close(){ wrap.style.display='none'; }

    // Comenzi disponibile (apelează APIs existente dacă există)
    var items = [
      { title:'Undo', hint:'Ctrl+Z', action:function(){ window.undo && window.undo(); } },
      { title:'Redo', hint:'Ctrl+Shift+Z / Ctrl+Y', action:function(){ window.redo && window.redo(); } },
      { title:'Reset project', action:function(){ window.resetDesign && window.resetDesign(); } },
      { title:'Save project (localStorage)', hint:'Ctrl+S', action:function(){ window.LCS_Project && window.LCS_Project.saveToLocal(); } },
      { title:'Load autosave', action:function(){ window.LCS_Project && window.LCS_Project.loadFromLocal(); } },
      { title:'Export .lcs', action:function(){ window.LCS_Project && window.LCS_Project.export(); } },
      { title:'Export SVG for Laser', action:function(){ window.LCS_Project && window.LCS_Project.exportSVG && window.LCS_Project.exportSVG(); } },
      { title:'Import .lcs', hint:'Ctrl+O', action:function(){ var el=document.getElementById('lcs-import'); if(el) el.click(); } },
      { title:'Zoom: reset to 100%', action:function(){ try{ var s=window.getSnapshot(); s.zoom=1; window.applySnapshot(s); window.LCS && window.LCS.history && window.LCS.history.push('zoom-reset'); }catch(_){} } },
      { title:'Unit: toggle mm/in', action:function(){ try{ var s=window.getSnapshot(); s.unit=(s.unit==='mm'?'in':'mm'); window.applySnapshot(s); window.LCS && window.LCS.history && window.LCS.history.push('unit-toggle'); }catch(_){} } },
      { title:'Open settings', action:function(){ var b=document.getElementById('lcs-gear-btn'); if(b){ b.click(); } } },
    ];

    function matchScore(s, q){
      s = s.toLowerCase(); q = q.toLowerCase().trim();
      if (!q) return 1;
      var i=0; for (var c of q){ i = s.indexOf(c, i); if (i === -1) return 0; i++; }
      return q.length / s.length + (s.startsWith(q)?0.5:0); // fuzzy + boost prefix
    }
    function render(data, needle){
      var scored = data.map(function(it){ return {it:it, sc: matchScore(it.title + ' ' + (it.hint||''), needle||'')}; })
                       .filter(function(x){ return x.sc>0; })
                       .sort(function(a,b){ return b.sc - a.sc; })
                       .map(function(x){ return x.it; });
      list.innerHTML = '';
      var idx = 0;
      scored.forEach(function(it, i){
        var li = document.createElement('li');
        li.tabIndex = 0;
        li.className = i===0 ? 'active' : '';
        li.innerHTML = '<span>'+it.title+'</span>' + (it.hint?'<small class="kbd">'+it.hint+'</small>':'');
        li.addEventListener('click', function(){ run(it); });
        list.appendChild(li);
      });
      // keyboard nav
      var pos = 0;
      function setActive(n){
        var items = list.querySelectorAll('li');
        if (!items.length) return;
        pos = (n+items.length) % items.length;
        items.forEach(function(el){ el.classList.remove('active'); });
        items[pos].classList.add('active');
        items[pos].scrollIntoView({block:'nearest'});
      }
      setActive(0);
      q.oninput = function(){ render(items, q.value); };
      q.onkeydown = function(e){
        if (e.key === 'ArrowDown'){ e.preventDefault(); setActive(pos+1); }
        else if (e.key === 'ArrowUp'){ e.preventDefault(); setActive(pos-1); }
        else if (e.key === 'Enter'){ e.preventDefault(); var li=list.querySelectorAll('li')[pos]; if(li){ li.click(); } }
        else if (e.key === 'Escape'){ e.preventDefault(); close(); }
      };
      wrap.onkeydown = function(e){ if (e.key === 'Escape'){ e.preventDefault(); close(); } };
      wrap.onclick = function(e){ if (e.target === wrap) close(); };
    }

    // Shortcut Ctrl+K pentru deschidere (fără a fura input-urile)
    function isEditable(el){ if(!el) return false; var t=(el.tagName||'').toLowerCase(); return ['input','textarea','select'].includes(t) || !!el.isContentEditable; }
    window.addEventListener('keydown', function(e){
      if (!e.ctrlKey && !e.metaKey) return;
      if (isEditable(e.target)) return;
      var k=(e.key||'').toLowerCase();
      if (k === 'k'){ e.preventDefault(); open(); }
    }, {passive:false});
  })();
  </script>
<!-- Status bar: unit, zoom, canvas size, cursor -->
<style>
  #lcs-statusbar{position:fixed;left:0;right:0;bottom:0;z-index:99980;background:#111827;color:#e5e7eb;padding:6px 10px;font:12px/1.2 system-ui;display:flex;gap:16px;align-items:center}
  #lcs-statusbar .item{opacity:.9}
</style>
<div id="lcs-statusbar">
  <div class="item" id="sb-unit">Unit: mm</div>
  <div class="item" id="sb-zoom">Zoom: 100%</div>
  <div class="item" id="sb-canvas">Canvas: —</div>
  <div class="item" id="sb-cursor">Cursor: —</div>
</div>
<script>
(function(){
  if (window.__LCS_STATUSBAR__) return; window.__LCS_STATUSBAR__=true;
  var elU = document.getElementById('sb-unit'),
      elZ = document.getElementById('sb-zoom'),
      elC = document.getElementById('sb-canvas'),
      elP = document.getElementById('sb-cursor');
  function snap(){ try{ return (window.getSnapshot&&window.getSnapshot())||{} }catch(_){ return {} } }
  function svg(){ var a=[].slice.call(document.querySelectorAll('svg')); if(!a.length) return null;
    a.sort(function(A,B){function ar(x){var vb=(x.getAttribute('viewBox')||'').split(/\s+/).map(Number);if(vb.length===4&&vb.every(isFinite))return vb[2]*vb[3];var r=x.getBoundingClientRect();return r.width*r.height||0} return ar(B)-ar(A)}); return a[0] }
  function zoom(){ var s=snap(); var z=Number(s.zoom); return (isFinite(z)&&z>0)?z:1 }
  function unit(){ var u=(snap().unit||'mm'); return (u==='inches'||u==='inch')?'in':u }
  function updateBasics(){
    var s=snap(); var u=unit(); var z=zoom();
    if (elU) elU.textContent = 'Unit: '+u;
    if (elZ) elZ.textContent = 'Zoom: '+Math.round(z*100)+'%';
    var w=0,h=0, sv=svg();
    var canvas = s.canvas||{};
    if (typeof canvas.width==='number' && typeof canvas.height==='number'){ w=canvas.width; h=canvas.height; }
    else if (sv){ var vb=(sv.getAttribute('viewBox')||'').split(/\s+/).map(Number); if(vb.length===4&&vb.every(isFinite)){ w=vb[2]; h=vb[3]; } }
    if (elC) elC.textContent = 'Canvas: ' + (w|0) + '×' + (h|0) + ' px';
  }
  function setupPointer(){
    var sv=svg(); if(!sv) return;
    sv.addEventListener('mousemove', function(e){
      try{
        var pt = sv.createSVGPoint(); pt.x=e.clientX; pt.y=e.clientY;
        var ctm = sv.getScreenCTM(); if(!ctm) return;
        var ip = pt.matrixTransform(ctm.inverse());
        var u=unit(), px2 = (u==='in') ? (1/96) : (25.4/96);
        elP && (elP.textContent = 'Cursor: ' + (ip.x*px2).toFixed(2) + ' ' + u + ', ' + (ip.y*px2).toFixed(2) + ' ' + u);
      }catch(_){}}
    );
  }
  updateBasics(); setupPointer();
  window.addEventListener('lcs:state-applied', updateBasics);
  window.addEventListener('lcs:zoom-changed', updateBasics);
})();
</script>

<!-- Zoom UI + keyboard -->
<style>
  #lcs-zoom {position:fixed;right:16px;bottom:140px;z-index:99990;background:#fff;border:1px solid #e5e7eb;border-radius:12px;box-shadow:0 6px 24px rgba(0,0,0,.15);padding:6px;display:flex;gap:6px;align-items:center}
  #lcs-zoom button{width:34px;height:34px;border:1px solid #e5e7eb;border-radius:8px;background:#fff;cursor:pointer;font:600 14px/1 system-ui}
  #lcs-zoom .val{min-width:58px;text-align:center;font:600 12px/1 system-ui;color:#111827}
</style>
<div id="lcs-zoom" title="Zoom">
  <button id="z-out" aria-label="Zoom out">−</button>
  <div class="val" id="z-val">100%</div>
  <button id="z-in" aria-label="Zoom in">+</button>
  <button id="z-reset" aria-label="Reset zoom">100%</button>
</div>
<script>
(function(){
  if (window.__LCS_ZOOM_UI__) return; window.__LCS_ZOOM_UI__=true;
  var elV=document.getElementById('z-val'), btnIn=document.getElementById('z-in'), btnOut=document.getElementById('z-out'), btnR=document.getElementById('z-reset');
  function getSnap(){ try{ return (window.getSnapshot&&window.getSnapshot())||{} }catch(_){ return {} } }
  function setSnap(s){ try{ if(window.applySnapshot) window.applySnapshot(s) }catch(_){} }
  function mainSVG(){ var a=[].slice.call(document.querySelectorAll('svg')); if(!a.length) return null; a.sort(function(A,B){function ar(x){var vb=(x.getAttribute('viewBox')||'').split(/\s+/).map(Number);if(vb.length===4&&vb.every(isFinite))return vb[2]*vb[3];var r=x.getBoundingClientRect();return r.width*r.height||0} return ar(B)-ar(A)}); return a[0] }
  function getZoom(){ var s=getSnap(); var z=Number(s.zoom); if(!isFinite(z)||z<=0) z=1; return z }
  function show(z){ if(elV) elV.textContent = Math.round(z*100)+'%'; }
  function applyZoom(z){
    z=Math.max(0.1,Math.min(8,Number(z)||1));
    var s=getSnap(); s.zoom=z; setSnap(s);
    var svg=mainSVG(); if(svg){ svg.style.transformOrigin='0 0'; svg.style.transform='scale('+z+')'; }
    show(z);
    try{ window.dispatchEvent(new CustomEvent('lcs:zoom-changed',{detail:{zoom:z}})); }catch(_){}
    try{ window.LCS && window.LCS.history && window.LCS.history.push('zoom'); }catch(_){}
  }
  btnIn && (btnIn.onclick = function(){ applyZoom(getZoom()+0.1); });
  btnOut && (btnOut.onclick = function(){ applyZoom(getZoom()-0.1); });
  btnR && (btnR.onclick = function(){ applyZoom(1); });
  show(getZoom());
  // Ctrl+=/+, Ctrl-, Ctrl+0
  window.addEventListener('keydown', function(e){
    var k=(e.key||'').toLowerCase(); if(!(e.ctrlKey||e.metaKey)) return;
    if (k==='=' || k==='+'){ e.preventDefault(); applyZoom(getZoom()+0.1); }
    else if(k==='-'){ e.preventDefault(); applyZoom(getZoom()-0.1); }
    else if(k==='0'){ e.preventDefault(); applyZoom(1); }
  }, {passive:false});
  window.addEventListener('lcs:state-applied', function(){ show(getZoom()); });
})();
</script>

<!-- Marquee Selection (drag to select multiple) – fixed for re-renders -->
<style>
  svg .selected { outline: none; }
</style>
<script>
(function(){
  if (window.__LCS_MARQUEE__) return; window.__LCS_MARQUEE__ = true;

  function mainSVG(){
    var a=[].slice.call(document.querySelectorAll('svg')); if(!a.length) return null;
    a.sort(function(A,B){
      function area(x){var vb=(x.getAttribute('viewBox')||'').split(/\s+/).map(Number);
        if(vb.length===4&&vb.every(isFinite))return vb[2]*vb[3];
        var r=x.getBoundingClientRect(); return r.width*r.height||0;}
      return area(B)-area(A);
    });
    return a[0];
  }
  function svgPoint(svg, clientX, clientY){
    var pt = svg.createSVGPoint(); pt.x = clientX; pt.y = clientY;
    var m = svg.getScreenCTM(); if (!m) return {x:clientX,y:clientY};
    var p = pt.matrixTransform(m.inverse()); return {x:p.x, y:p.y};
  }
  function ensureMarqueeRect(svg){
    var g = svg.querySelector('g.lcs-marquee');
    if (!g){ g = document.createElementNS('http://www.w3.org/2000/svg','g'); g.setAttribute('class','lcs-marquee'); svg.appendChild(g); }
    var r = g.querySelector('#lcs-marquee-rect');
    if (!r){
      r = document.createElementNS('http://www.w3.org/2000/svg','rect');
      r.setAttribute('id','lcs-marquee-rect');
      r.setAttribute('fill','#3b82f6'); r.setAttribute('fill-opacity','0.12');
      r.setAttribute('stroke','#3b82f6'); r.setAttribute('stroke-width','1');
      r.setAttribute('stroke-dasharray','4,3'); r.setAttribute('pointer-events','none');
      r.setAttribute('visibility','hidden'); g.appendChild(r);
    }
    return r;
  }
  function selectableNodes(svg){
    var list = [].slice.call(svg.querySelectorAll('path,rect,circle,ellipse,polygon,polyline,g'));
    return list.filter(function(n){
      var tn = (n.tagName||'').toLowerCase();
      if (tn==='svg'||tn==='defs'||tn==='clippath'||tn==='title'||tn==='desc') return false;
      if (n.closest('defs')) return false;
      return true;
    });
  }
  function bboxOf(el){ try{ var b = el.getBBox(); return {x:b.x,y:b.y,width:b.width,height:b.height}; }catch(_){ return null; } }
  function rectsOverlap(a,b){ return a && b && (a.x < b.x + b.width) && (a.x + a.width > b.x) && (a.y < b.y + b.height) && (a.y + a.height > b.y); }
  function normalizeRect(x1,y1,x2,y2){ var x=Math.min(x1,x2),y=Math.min(y1,y2); return {x:x,y:y,width:Math.abs(x2-x1),height:Math.abs(y2-y1)}; }
  function clearSelection(svg){ [].slice.call(svg.querySelectorAll('[data-selected="1"],.selected')).forEach(function(n){ n.removeAttribute('data-selected'); n.classList.remove('selected'); }); }
  function addSelected(nodes){ nodes.forEach(function(n){ n.setAttribute('data-selected','1'); n.classList.add('selected'); }); }
  function canStartMarquee(e){ if (e.altKey) return true; return e.target === curSvg; }

  var curSvg=null, rect=null;
  var drag = {active:false, start:{x:0,y:0}, additive:false, forced:false};

  document.addEventListener('mousedown', function(e){
    if (e.button!==0) return;
    curSvg = (e.target && e.target.closest && e.target.closest('svg')) || mainSVG();
    if (!curSvg) return;
    if (!canStartMarquee(e) && e.target!==curSvg) return;
    rect = ensureMarqueeRect(curSvg);
    var p = svgPoint(curSvg, e.clientX, e.clientY);
    drag.active = true; drag.start = p;
    drag.additive = !!(e.shiftKey || e.ctrlKey || e.metaKey);
    drag.forced = !!e.altKey;
    rect.setAttribute('x', p.x); rect.setAttribute('y', p.y);
    rect.setAttribute('width', 0); rect.setAttribute('height', 0);
    rect.setAttribute('visibility','visible');
    e.preventDefault();
  }, true);

  window.addEventListener('mousemove', function(e){
    if (!drag.active || !curSvg || !rect) return;
    var p = svgPoint(curSvg, e.clientX, e.clientY);
    var r = normalizeRect(drag.start.x, drag.start.y, p.x, p.y);
    rect.setAttribute('x', r.x); rect.setAttribute('y', r.y);
    rect.setAttribute('width', r.width); rect.setAttribute('height', r.height);
    e.preventDefault();
  }, true);

  window.addEventListener('mouseup', function(e){
    if (!drag.active || !curSvg || !rect) return;
    var end = svgPoint(curSvg, e.clientX, e.clientY);
    var selRect = normalizeRect(drag.start.x, drag.start.y, end.x, end.y);
    rect.setAttribute('visibility','hidden');
    drag.active = false;

    var candidates = selectableNodes(curSvg);
    var picked = [];
    for (var i=0;i<candidates.length;i++){
      var bb = bboxOf(candidates[i]); if (!bb) continue;
      if (rectsOverlap(selRect, bb)) picked.push(candidates[i]);
    }
    if (!drag.additive) clearSelection(curSvg);
    addSelected(picked);
    try { window.LCS && window.LCS.history && window.LCS.history.push('marquee-select'); }catch(_){}
    e.preventDefault();
  }, true);
})();
  </script>
  <!-- BOOT: start with empty canvas (wipe default demo once per page load) -->
  <script>
  (function(){
    if (window.__LCS_BOOT_EMPTY__) return; window.__LCS_BOOT_EMPTY__=true;
    // pornește o singură dată pe sesiune (tab)
    if (sessionStorage.getItem('LCS:bootCleared')==='1') return;
    function mainSVG(){
      var a=[].slice.call(document.querySelectorAll('svg')); if(!a.length) return null;
      a.sort(function(A,B){
        function ar(x){var vb=(x.getAttribute('viewBox')||'').split(/\s+/).map(Number);
          if(vb.length===4&&vb.every(isFinite))return vb[2]*vb[3]; var r=x.getBoundingClientRect(); return r.width*r.height||0}
        return ar(B)-ar(A);
      });
      return a[0];
    }
    function wipe(svg){
      if (!svg) return false;
      var keep = {defs:1,title:1,desc:1,metadata:1,clipPath:1,mask:1,pattern:1,linearGradient:1,radialGradient:1};
      // păstrăm doar defs/metadata; golim restul
      [].slice.call(svg.childNodes).forEach(function(n){
        if (n.nodeType!==1) return; // element nodes
        var t=(n.tagName||'').toLowerCase();
        if (!keep[t]) { try{ n.remove(); }catch(_){}} 
      });
      // creăm un strat "root" gol pentru app
      var g=document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class','lcs-root'); g.setAttribute('data-export','true');
      svg.appendChild(g);
      try{ window.LCS && window.LCS.history && window.LCS.history.push('boot-clear'); }catch(_){}
      return true;
    }
    // așteaptă până când React a montat SVG-ul
    var tries=0;
    (function tick(){
      var svg = mainSVG();
      if (svg && wipe(svg)){
        sessionStorage.setItem('LCS:bootCleared','1');
        return;
      }
      if (++tries<120) return setTimeout(tick, 50); // până la ~6s
    })();
  })();
  </script>
</body>
</html>
